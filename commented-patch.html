<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>SBCL Windows threads patches</title>
    <link rel="stylesheet" type="text/css" href="commented-patch.css">
  </head>
  <body>
<!-- Generator: GNU source-highlight 3.1
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>diff --git a/contrib/sb-concurrency/tests/test-mailbox.lisp b/contrib/sb-concurrency/tests/test-mailbox.lisp
old mode 100644
new mode 100755
index 5243446..f9cbc2b
<font color="#FF6600">--- a/contrib/sb-concurrency/tests/test-mailbox.lisp</font>
<font color="#009900">+++ b/contrib/sb-concurrency/tests/test-mailbox.lisp</font>
<font color="#0000FF">@@ -173,10 +173,10 @@</font>
   (:timeouts . 0))
 
 (deftest mailbox.multiple-producers-multiple-consumers
<font color="#FF6600">-    (test-mailbox-producers-consumers :n-senders 100</font>
<font color="#FF6600">-                                      :n-receivers 100</font>
<font color="#FF6600">-                                      :n-messages 1000)</font>
<font color="#FF6600">-  (:received . 100000)</font>
<font color="#009900">+    (test-mailbox-producers-consumers :n-senders 10</font>
<font color="#009900">+                                      :n-receivers 10</font>
<font color="#009900">+                                      :n-messages 100)</font>
<font color="#009900">+  (:received . 1000)</font>
   (:garbage  . 0)
   (:errors   . 0)
   (:timeouts . 0))
<font color="#0000FF">@@ -184,15 +184,15 @@</font>
 (deftest mailbox.interrupts-safety.1
     (multiple-value-bind (received garbage errors timeouts)
         (test-mailbox-producers-consumers
<font color="#FF6600">-         :n-senders 100</font>
<font color="#FF6600">-         :n-receivers 100</font>
<font color="#009900">+         :n-senders 10</font>
<font color="#009900">+         :n-receivers 10</font>
          :n-messages 1000
          :interruptor #'(lambda (threads &amp;aux (n (length threads)))
                           ;; 99 so even in the unlikely case that only
                           ;; receivers (or only senders) are shot
                           ;; dead, there's still one that survives to
                           ;; properly end the test.
<font color="#FF6600">-                          (loop repeat 99</font>
<font color="#009900">+                          (loop repeat 19</font>
                                 for victim = (nth (random n) threads)
                                 do (kill-thread victim)
                                    (sleep (random 0.0001)))))
diff --git a/make-config.sh b/make-config.sh
index fcdd9f9..51ee466 100644
<font color="#FF6600">--- a/make-config.sh</font>
<font color="#009900">+++ b/make-config.sh</font>
<font color="#0000FF">@@ -261,6 +261,7 @@ case "$sbcl_os" in</font>
         ;;
     win32)
         printf ' :win32' &gt;&gt; $ltf
<font color="#009900">+        printf ' :sb-pthread-futex' &gt;&gt; $ltf</font>
         link_or_copy Config.$sbcl_arch-win32 Config
         link_or_copy $sbcl_arch-win32-os.h target-arch-os.h
         link_or_copy win32-os.h target-os.h
diff --git a/package-data-list.lisp-expr b/package-data-list.lisp-expr
index e99ff95..7e3f182 100644
<font color="#FF6600">--- a/package-data-list.lisp-expr</font>
<font color="#009900">+++ b/package-data-list.lisp-expr</font>
<font color="#0000FF">@@ -2722,6 +2722,7 @@ structure representations"</font>
                #!+linkage-table "LINKAGE-TABLE-SPACE-START"
                #!+linkage-table "LINKAGE-TABLE-SPACE-END"
                #!+linkage-table "LINKAGE-TABLE-ENTRY-SIZE"
<font color="#009900">+               #!+(and sb-thread win32) "GC-SAFEPOINT-PAGE-ADDR"</font>
                "TLS-SIZE"
                "TRACE-TABLE-CALL-SITE"
                "TRACE-TABLE-FUN-EPILOGUE" "TRACE-TABLE-FUN-PROLOGUE"
diff --git a/src/code/cold-init.lisp b/src/code/cold-init.lisp
index d8c1160..aaf100c 100644
<font color="#FF6600">--- a/src/code/cold-init.lisp</font>
<font color="#009900">+++ b/src/code/cold-init.lisp</font>
<font color="#0000FF">@@ -229,7 +229,8 @@</font>
   (show-and-call stream-cold-init-or-reset)
   (show-and-call !loader-cold-init)
   (show-and-call !foreign-cold-init)
<font color="#FF6600">-  #!-win32 (show-and-call signal-cold-init-or-reinit)</font>
<font color="#009900">+  #!-(and win32 (not sb-thread))</font>
<font color="#009900">+  (show-and-call signal-cold-init-or-reinit)</font>
   (/show0 "enabling internal errors")
   (setf (sb!alien:extern-alien "internal_errors_enabled" boolean) t)
 
<font color="#0000FF">@@ -305,7 +306,7 @@ systems, UNIX-STATUS is used as the status code."</font>
     (os-cold-init-or-reinit)
     (thread-init-or-reinit)
     (stream-reinit t)
<font color="#FF6600">-    #!-win32</font>
<font color="#009900">+    #!-(and win32 (not sb-thread))</font>
     (signal-cold-init-or-reinit)
     (setf (sb!alien:extern-alien "internal_errors_enabled" boolean) t)
     (float-cold-init-or-reinit))
diff --git a/src/code/early-impl.lisp b/src/code/early-impl.lisp
index 51fe656..f9f3da3 100644
<font color="#FF6600">--- a/src/code/early-impl.lisp</font>
<font color="#009900">+++ b/src/code/early-impl.lisp</font>
<font color="#0000FF">@@ -38,6 +38,12 @@</font>
                   sb!unix::*unblock-deferrables-on-enabling-interrupts-p*
                   *interrupts-enabled*
                   *interrupt-pending*
<font color="#009900">+                  #!+(and win32 sb-thread)</font>
<font color="#009900">+                  *gc-safe*</font>
<font color="#009900">+                  #!+(and win32 sb-thread)</font>
<font color="#009900">+                  *in-safepoint*</font>
<font color="#009900">+                  #!+(and win32 sb-thread)</font>
<font color="#009900">+                  *disable-safepoints*</font>
                   *free-interrupt-context-index*
                   sb!kernel::*gc-epoch*
                   sb!vm::*unwind-to-frame-function*
diff --git a/src/code/gc.lisp b/src/code/gc.lisp
index 042ab05..fa83985 100644
<font color="#FF6600">--- a/src/code/gc.lisp</font>
<font color="#009900">+++ b/src/code/gc.lisp</font>
<font color="#0000FF">@@ -231,6 +231,8 @@ run in any thread.")</font>
                        ;; turn is a type-error.
                        (when (plusp run-time)
                          (incf *gc-run-time* run-time))))
<font color="#009900">+                   #!+(and win32 sb-thread)</font>
<font color="#009900">+                   (setf *stop-for-gc-pending* nil)</font>
                    (setf *gc-pending* nil
                          new-usage (dynamic-usage))
                    #!+sb-thread
diff --git a/src/code/target-exception.lisp b/src/code/target-exception.lisp
index 803a758..3ceacf2 100644
<font color="#FF6600">--- a/src/code/target-exception.lisp</font>
<font color="#009900">+++ b/src/code/target-exception.lisp</font>
<font color="#0000FF">@@ -101,3 +101,111 @@</font>
 ;;;   I don't know if we still need this or not. Better safe for now.
 (defun receive-pending-interrupt ()
   (receive-pending-interrupt))
<font color="#009900">+</font>
<font color="#009900">+(in-package "SB!UNIX")</font>
<font color="#009900">+</font>
<font color="#009900">+#!+sb-thread</font>
<font color="#009900">+(progn</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun receive-pending-interrupt ()</font>
<font color="#009900">+    (receive-pending-interrupt))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defmacro with-interrupt-bindings (&amp;body body)</font>
<font color="#009900">+    `(let*</font>
<font color="#009900">+         ;; KLUDGE: Whatever is on the PCL stacks before the interrupt</font>
<font color="#009900">+         ;; handler runs doesn't really matter, since we're not on the</font>
<font color="#009900">+         ;; same call stack, really -- and if we don't bind these (esp.</font>
<font color="#009900">+         ;; the cache one) we can get a bogus metacircle if an interrupt</font>
<font color="#009900">+         ;; handler calls a GF that was being computed when the interrupt</font>
<font color="#009900">+         ;; hit.</font>
<font color="#009900">+         ((sb!pcl::*cache-miss-values-stack* nil)</font>
<font color="#009900">+          (sb!pcl::*dfun-miss-gfs-on-stack* nil))</font>
<font color="#009900">+       ,@body))</font>
<font color="#009900">+</font>
<font color="#009900">+  ;;; Evaluate CLEANUP-FORMS iff PROTECTED-FORM does a non-local exit.</font>
<font color="#009900">+  (defmacro nlx-protect (protected-form &amp;rest cleanup-froms)</font>
<font color="#009900">+    (with-unique-names (completep)</font>
<font color="#009900">+      `(let ((,completep nil))</font>
<font color="#009900">+         (without-interrupts</font>
<font color="#009900">+           (unwind-protect</font>
<font color="#009900">+                (progn</font>
<font color="#009900">+                  (allow-with-interrupts</font>
<font color="#009900">+                    ,protected-form)</font>
<font color="#009900">+                  (setq ,completep t))</font>
<font color="#009900">+             (unless ,completep</font>
<font color="#009900">+               ,@cleanup-froms))))))</font>
<font color="#009900">+</font>
<font color="#009900">+  (declaim (inline %unblock-deferrable-signals %unblock-gc-signals))</font>
<font color="#009900">+  (sb!alien:define-alien-routine ("unblock_deferrable_signals"</font>
<font color="#009900">+                                  %unblock-deferrable-signals)</font>
<font color="#009900">+      sb!alien:void</font>
<font color="#009900">+    (where sb!alien:unsigned-long)</font>
<font color="#009900">+    (old sb!alien:unsigned-long))</font>
<font color="#009900">+  (sb!alien:define-alien-routine ("unblock_gc_signals" %unblock-gc-signals)</font>
<font color="#009900">+      sb!alien:void</font>
<font color="#009900">+    (where sb!alien:unsigned-long)</font>
<font color="#009900">+    (old sb!alien:unsigned-long))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun block-deferrable-signals ()</font>
<font color="#009900">+    (%block-deferrable-signals 0 0))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun unblock-deferrable-signals ()</font>
<font color="#009900">+    (%unblock-deferrable-signals 0 0))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun unblock-gc-signals ()</font>
<font color="#009900">+    (%unblock-gc-signals 0 0))</font>
<font color="#009900">+    </font>
<font color="#009900">+  (declaim (inline %block-deferrables-and-return-mask %apply-sigmask))</font>
<font color="#009900">+  (sb!alien:define-alien-routine ("block_deferrables_and_return_mask"</font>
<font color="#009900">+                                  %block-deferrables-and-return-mask)</font>
<font color="#009900">+      sb!alien:unsigned-long)</font>
<font color="#009900">+  (sb!alien:define-alien-routine ("apply_sigmask"</font>
<font color="#009900">+                                  %apply-sigmask)</font>
<font color="#009900">+      sb!alien:void</font>
<font color="#009900">+      (mask sb!alien:unsigned-long))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defmacro without-interrupts/with-deferrables-blocked (&amp;body body)</font>
<font color="#009900">+    (let ((mask-var (gensym)))</font>
<font color="#009900">+      `(without-interrupts</font>
<font color="#009900">+         (let ((,mask-var (%block-deferrables-and-return-mask)))</font>
<font color="#009900">+           (unwind-protect</font>
<font color="#009900">+               (progn ,@body)</font>
<font color="#009900">+             (%apply-sigmask ,mask-var))))))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun invoke-interruption (function)</font>
<font color="#009900">+    (without-interrupts/with-deferrables-blocked</font>
<font color="#009900">+      ;; Reset signal mask: the C-side handler has blocked all</font>
<font color="#009900">+      ;; deferrable signals before funcalling into lisp. They are to be</font>
<font color="#009900">+      ;; unblocked the first time interrupts are enabled. With this</font>
<font color="#009900">+      ;; mechanism there are no extra frames on the stack from a</font>
<font color="#009900">+      ;; previous signal handler when the next signal is delivered</font>
<font color="#009900">+      ;; provided there is no WITH-INTERRUPTS.</font>
<font color="#009900">+      (let ((sb!unix::*unblock-deferrables-on-enabling-interrupts-p* t))</font>
<font color="#009900">+        (with-interrupt-bindings</font>
<font color="#009900">+          (let ((sb!debug:*stack-top-hint*</font>
<font color="#009900">+                 (nth-value 1 (sb!kernel:find-interrupted-name-and-frame))))</font>
<font color="#009900">+            (allow-with-interrupts</font>
<font color="#009900">+              (nlx-protect (funcall function)</font>
<font color="#009900">+                           ;; We've been running with deferrables</font>
<font color="#009900">+                           ;; blocked in Lisp called by a C signal</font>
<font color="#009900">+                           ;; handler. If we return normally the sigmask</font>
<font color="#009900">+                           ;; in the interrupted context is restored.</font>
<font color="#009900">+                           ;; However, if we do an nlx the operating</font>
<font color="#009900">+                           ;; system will not restore it for us.</font>
<font color="#009900">+                           (when sb!unix::*unblock-deferrables-on-enabling-interrupts-p*</font>
<font color="#009900">+                             ;; This means that storms of interrupts</font>
<font color="#009900">+                             ;; doing an nlx can still run out of stack.</font>
<font color="#009900">+                             (unblock-deferrable-signals)))))))))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defmacro in-interruption ((&amp;key) &amp;body body)</font>
<font color="#009900">+    #!+sb-doc</font>
<font color="#009900">+    "Convenience macro on top of INVOKE-INTERRUPTION."</font>
<font color="#009900">+    `(dx-flet ((interruption () ,@body))</font>
<font color="#009900">+       (invoke-interruption #'interruption)))</font>
<font color="#009900">+    </font>
<font color="#009900">+  (defun sb!kernel:signal-cold-init-or-reinit ()</font>
<font color="#009900">+    #!+sb-doc</font>
<font color="#009900">+    "Enable all the default signals that Lisp knows how to deal with."</font>
<font color="#009900">+    (unblock-gc-signals)</font>
<font color="#009900">+    (unblock-deferrable-signals)</font>
<font color="#009900">+    (values)))</font>
diff --git a/src/code/target-thread.lisp b/src/code/target-thread.lisp
index 111f92b..7e7474c 100644
<font color="#FF6600">--- a/src/code/target-thread.lisp</font>
<font color="#009900">+++ b/src/code/target-thread.lisp</font>
<font color="#0000FF">@@ -351,6 +351,8 @@ HOLDING-MUTEX-P."</font>
   "Deprecated in favor of GRAB-MUTEX."
   (declare (type mutex mutex) (optimize (speed 3))
            #!-sb-thread (ignore waitp timeout))
<font color="#009900">+  (let (#!+(and win32 sb-thread) (sb!impl::*disable-safepoints* t))</font>
<font color="#009900">+  ;; FIXME: reindent after merging windows-threads</font>
   (unless new-owner
     (setq new-owner *current-thread*))
   (barrier (:read))
<font color="#0000FF">@@ -426,7 +428,7 @@ HOLDING-MUTEX-P."</font>
                  (bug "Old owner in free mutex: ~S" prev))
                t))
             (waitp
<font color="#FF6600">-             (bug "Failed to acquire lock with WAITP."))))))</font>
<font color="#009900">+             (bug "Failed to acquire lock with WAITP.")))))))</font>
 
 (defun grab-mutex (mutex &amp;key (waitp t) (timeout nil))
   #!+sb-doc
<font color="#0000FF">@@ -484,6 +486,8 @@ IF-NOT-OWNER is :FORCE)."</font>
   (declare (type mutex mutex))
   ;; Order matters: set owner to NIL before releasing state.
   (let* ((self *current-thread*)
<font color="#009900">+         #!+(and win32 sb-thread)</font>
<font color="#009900">+         (sb!impl::*disable-safepoints* t)</font>
          (old-owner (sb!ext:compare-and-swap (mutex-%owner mutex) self nil)))
     (unless (eql self old-owner)
       (ecase if-not-owner
<font color="#0000FF">@@ -571,6 +575,7 @@ call, checking the the associated data:</font>
 Also note that if CONDITION-WAIT unwinds (due to eg. a timeout) instead of
 returning normally, it may do so without holding the mutex."
   #!-sb-thread (declare (ignore queue))
<font color="#009900">+  (let (#!+(and win32 sb-thread) (sb!impl::*disable-safepoints* t))</font>
   (assert mutex)
   #!-sb-thread (error "Not supported in unithread builds.")
   #!+sb-thread
<font color="#0000FF">@@ -641,7 +646,7 @@ returning normally, it may do so without holding the mutex."</font>
             ((2))
             ;; EWOULDBLOCK, -1 here, is the possible spurious wakeup
             ;; case. 0 is the normal wakeup.
<font color="#FF6600">-            (otherwise (return))))))))</font>
<font color="#009900">+            (otherwise (return)))))))))</font>
 
 (defun condition-notify (queue &amp;optional (n 1))
   #!+sb-doc
<font color="#0000FF">@@ -652,6 +657,8 @@ this call."</font>
   #!-sb-thread (error "Not supported in unithread builds.")
   #!+sb-thread
   (declare (type (and fixnum (integer 1)) n))
<font color="#009900">+  (let (#!+(and win32 sb-thread) (sb!impl::*disable-safepoints* t))</font>
<font color="#009900">+  ;; FIXME: reindent after merging windows-threads</font>
   (/show0 "Entering CONDITION-NOTIFY")
   #!+sb-thread
   (progn
<font color="#0000FF">@@ -670,7 +677,7 @@ this call."</font>
     (progn
       (setf (waitqueue-token queue) queue)
       (with-pinned-objects (queue)
<font color="#FF6600">-        (futex-wake (waitqueue-token-address queue) n)))))</font>
<font color="#009900">+        (futex-wake (waitqueue-token-address queue) n))))))</font>
 
 (defun condition-broadcast (queue)
   #!+sb-doc
<font color="#0000FF">@@ -934,6 +941,8 @@ have the foreground next."</font>
 
 
 ;;;; The beef
<font color="#009900">+#!+(and win32 sb-thread)</font>
<font color="#009900">+(sb!alien:define-alien-routine ("gc_safepoint" gc-safepoint) sb!alien:void)</font>
 
 (defun make-thread (function &amp;key name)
   #!+sb-doc
<font color="#0000FF">@@ -1003,10 +1012,12 @@ around and can be retrieved by JOIN-THREAD."</font>
                                ;; other threads, it's time to enable
                                ;; signals.
                                (sb!unix::unblock-deferrable-signals)
<font color="#FF6600">-                               (setf (thread-result thread)</font>
<font color="#FF6600">-                                     (cons t</font>
<font color="#009900">+                               (let ((r (cons t</font>
                                            (multiple-value-list
<font color="#FF6600">-                                            (funcall real-function))))</font>
<font color="#009900">+                                            (funcall real-function)))))</font>
<font color="#009900">+                                  #!+win32</font>
<font color="#009900">+                                  (gc-safepoint)</font>
<font color="#009900">+                                  (setf (thread-result thread) r))</font>
                                ;; Try to block deferrables. An
                                ;; interrupt may unwind it, but for a
                                ;; normal exit it prevents interrupt
<font color="#0000FF">@@ -1075,6 +1086,11 @@ return DEFAULT if given or else signal JOIN-THREAD-ERROR."</font>
       (kill-safely (thread-os-thread *current-thread*) sb!unix:sigpipe))
     (when interruption
       (funcall interruption))))
<font color="#009900">+      </font>
<font color="#009900">+#!+(and sb-thread win32)</font>
<font color="#009900">+(sb!alien:define-alien-routine interrupt-lisp-thread sb!alien:int</font>
<font color="#009900">+  (thread sb!alien:int)</font>
<font color="#009900">+  (fn sb!alien:int))</font>
 
 (defun interrupt-thread (thread function)
   #!+sb-doc
<font color="#0000FF">@@ -1088,11 +1104,22 @@ enable interrupts (GET-MUTEX when contended, for instance) so the</font>
 first thing to do is usually a WITH-INTERRUPTS or a
 WITHOUT-INTERRUPTS. Within a thread interrupts are queued, they are
 run in same the order they were sent."
<font color="#FF6600">-  #!+win32</font>
<font color="#FF6600">-  (declare (ignore thread))</font>
<font color="#FF6600">-  #!+win32</font>
<font color="#FF6600">-  (with-interrupt-bindings</font>
<font color="#FF6600">-    (with-interrupts (funcall function)))</font>
<font color="#009900">+  #!+(and sb-thread win32)</font>
<font color="#009900">+  (with-all-threads-lock</font>
<font color="#009900">+    (if (thread-alive-p thread)</font>
<font color="#009900">+	(let ((other-thread (sap-int (%thread-sap thread)))</font>
<font color="#009900">+	      (interrupt-function (lambda ()</font>
<font color="#009900">+				    (sb!unix::invoke-interruption function))))</font>
<font color="#009900">+	  (sb!sys:with-pinned-objects (interrupt-function)</font>
<font color="#009900">+	    (let ((r (interrupt-lisp-thread other-thread</font>
<font color="#009900">+					    (get-lisp-obj-address interrupt-function))))</font>
<font color="#009900">+	      (zerop r))))</font>
<font color="#009900">+	(error 'interrupt-thread-error :thread thread)))</font>
<font color="#009900">+  #!+(and (not sb-thread) win32)</font>
<font color="#009900">+  (progn</font>
<font color="#009900">+    (declare (ignore thread))</font>
<font color="#009900">+    (with-interrupt-bindings</font>
<font color="#009900">+      (with-interrupts (funcall function))))</font>
   #!-win32
   (let ((os-thread (thread-os-thread thread)))
     (cond ((not os-thread)
diff --git a/src/compiler/generic/genesis.lisp b/src/compiler/generic/genesis.lisp
index fac1eb4..dc6df79 100644
<font color="#FF6600">--- a/src/compiler/generic/genesis.lisp</font>
<font color="#009900">+++ b/src/compiler/generic/genesis.lisp</font>
<font color="#0000FF">@@ -2880,6 +2880,10 @@ core and return a descriptor to it."</font>
   ;; possibly this is another candidate for a rename (to
   ;; pseudo-atomic-trap-number or pseudo-atomic-magic-constant
   ;; [possibly applicable to other platforms])
<font color="#009900">+  </font>
<font color="#009900">+  #!+(and win32 sb-thread)</font>
<font color="#009900">+  (format t "#define GC_SAFEPOINT_PAGE_ADDR ((void*)0x~XUL) /* ~:*~A */~%"</font>
<font color="#009900">+            sb!vm:gc-safepoint-page-addr)</font>
 
   (dolist (symbol '(sb!vm::float-traps-byte
                     sb!vm::float-exceptions-byte
diff --git a/src/compiler/generic/parms.lisp b/src/compiler/generic/parms.lisp
index bbd4eae..09701de 100644
<font color="#FF6600">--- a/src/compiler/generic/parms.lisp</font>
<font color="#009900">+++ b/src/compiler/generic/parms.lisp</font>
<font color="#0000FF">@@ -81,6 +81,9 @@</font>
     *gc-pending*
     #!-sb-thread
     *stepping*
<font color="#009900">+    #!+(and win32 sb-thread) sb!impl::*gc-safe*</font>
<font color="#009900">+    #!+(and win32 sb-thread) sb!impl::*in-safepoint*</font>
<font color="#009900">+    #!+(and win32 sb-thread) sb!impl::*disable-safepoints*</font>
 
     ;; threading support
     #!+sb-thread *stop-for-gc-pending*
diff --git a/src/compiler/ir2tran.lisp b/src/compiler/ir2tran.lisp
index ebec113..b1456b3 100644
<font color="#FF6600">--- a/src/compiler/ir2tran.lisp</font>
<font color="#009900">+++ b/src/compiler/ir2tran.lisp</font>
<font color="#0000FF">@@ -1250,7 +1250,9 @@</font>
 
     (let ((lab (gen-label)))
       (setf (ir2-physenv-environment-start env) lab)
<font color="#FF6600">-      (vop note-environment-start node block lab)))</font>
<font color="#009900">+      (vop note-environment-start node block lab)</font>
<font color="#009900">+      #!+(and win32 sb-thread)</font>
<font color="#009900">+      (vop sb!vm::insert-gc-safepoint node block)))</font>
 
   (values))
 
<font color="#0000FF">@@ -1773,6 +1775,22 @@</font>
                        2block
                        #!+sb-dyncount *dynamic-counts-tn* #!-sb-dyncount nil
                        num))))
<font color="#009900">+              #!+(and win32 sb-thread)</font>
<font color="#009900">+              (let ((first-node (block-start-node block)))</font>
<font color="#009900">+                (unless (or (and (bind-p first-node)</font>
<font color="#009900">+                                 (xep-p (bind-lambda first-node)))</font>
<font color="#009900">+                            (and (valued-node-p first-node)</font>
<font color="#009900">+                                 (node-lvar first-node)</font>
<font color="#009900">+                                 (eq (lvar-fun-name</font>
<font color="#009900">+                                      (node-lvar first-node))</font>
<font color="#009900">+                                     '%nlx-entry)))</font>
<font color="#009900">+                  (when (and (rest (block-pred block))</font>
<font color="#009900">+                             (member (loop-kind (block-loop block))</font>
<font color="#009900">+                                     '(:natural :strange))</font>
<font color="#009900">+                             (eq block (loop-head (block-loop block))))</font>
<font color="#009900">+                    (vop sb!vm::insert-gc-safepoint</font>
<font color="#009900">+                         first-node</font>
<font color="#009900">+                         2block))))</font>
             (ir2-convert-block block)
             (incf num))))))
   (values))
diff --git a/src/compiler/x86/c-call.lisp b/src/compiler/x86/c-call.lisp
old mode 100644
new mode 100755
index 7eec472..d5e13c1
<font color="#FF6600">--- a/src/compiler/x86/c-call.lisp</font>
<font color="#009900">+++ b/src/compiler/x86/c-call.lisp</font>
<font color="#0000FF">@@ -272,7 +272,11 @@</font>
     ;; c-call.lisp. If you modify this, modify that one too...
     (cond ((policy node (&gt; space speed))
            (move eax function)
<font color="#FF6600">-           (inst call (make-fixup "call_into_c" :foreign)))</font>
<font color="#009900">+           #!+(and win32 sb-thread)</font>
<font color="#009900">+           (enter-safe-region-instructions)</font>
<font color="#009900">+           (inst call (make-fixup "call_into_c" :foreign))</font>
<font color="#009900">+           #!+(and win32 sb-thread)</font>
<font color="#009900">+           (leave-region-instructions))</font>
           (t
            ;; Setup the NPX for C; all the FP registers need to be
            ;; empty; pop them all.
<font color="#0000FF">@@ -283,7 +287,11 @@</font>
            ;; this, and it should not hurt others either.
            (inst cld)
 
<font color="#009900">+           #!+(and win32 sb-thread)</font>
<font color="#009900">+           (enter-safe-region-instructions)</font>
            (inst call function)
<font color="#009900">+           #!+(and win32 sb-thread)</font>
<font color="#009900">+           (leave-region-instructions)</font>
            ;; To give the debugger a clue. FIXME: not really internal-error?
            (note-this-location vop :internal-error)
 
<font color="#0000FF">@@ -348,7 +356,9 @@</font>
       (let ((delta (logandc2 (+ amount 3) 3)))
         (inst mov temp
               (make-ea-for-symbol-tls-index *alien-stack*))
<font color="#FF6600">-        (inst sub (make-ea :dword :base temp) delta :fs)))</font>
<font color="#009900">+        #!+(and win32 sb-thread)</font>
<font color="#009900">+        (inst add temp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+        (inst sub (make-ea :dword :base temp) delta #!-(and win32 sb-thread) :fs)))</font>
     (load-tl-symbol-value result *alien-stack*))
   #!-sb-thread
   (:generator 0
<font color="#0000FF">@@ -368,7 +378,9 @@</font>
       (let ((delta (logandc2 (+ amount 3) 3)))
         (inst mov temp
               (make-ea-for-symbol-tls-index *alien-stack*))
<font color="#FF6600">-        (inst add (make-ea :dword :base temp) delta :fs))))</font>
<font color="#009900">+        #!+(and win32 sb-thread)</font>
<font color="#009900">+        (inst add temp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+        (inst add (make-ea :dword :base temp) delta #!-(and win32 sb-thread) :fs))))</font>
   #!-sb-thread
   (:generator 0
     (unless (zerop amount)
<font color="#0000FF">@@ -413,6 +425,9 @@ pointer to the arguments."</font>
               (inst push eax)                       ; arg1
               (inst push (ash index 2))             ; arg0
 
<font color="#009900">+              #!+(and win32 sb-thread)</font>
<font color="#009900">+              (enter-unsafe-region-instructions/no-fixup)</font>
<font color="#009900">+              </font>
               ;; Indirect the access to ENTER-ALIEN-CALLBACK through
               ;; the symbol-value slot of SB-ALIEN::*ENTER-ALIEN-CALLBACK*
               ;; to ensure it'll work even if the GC moves ENTER-ALIEN-CALLBACK.
<font color="#0000FF">@@ -422,6 +437,9 @@ pointer to the arguments."</font>
               (inst push eax) ; function
               (inst mov  eax (foreign-symbol-address "funcall3"))
               (inst call eax)
<font color="#009900">+              </font>
<font color="#009900">+              #!+(and win32 sb-thread)</font>
<font color="#009900">+              (leave-region-instructions/no-fixup)</font>
               ;; now put the result into the right register
               (cond
                 ((and (alien-integer-type-p return-type)
diff --git a/src/compiler/x86/call.lisp b/src/compiler/x86/call.lisp
index cd90c1f..14b3f3c 100644
<font color="#FF6600">--- a/src/compiler/x86/call.lisp</font>
<font color="#009900">+++ b/src/compiler/x86/call.lisp</font>
<font color="#0000FF">@@ -1333,6 +1333,15 @@</font>
   ;; register on -SB-THREAD.
   #!+sb-thread
   (progn
<font color="#009900">+    #!+(and win32 sb-thread)</font>
<font color="#009900">+    (progn</font>
<font color="#009900">+      (inst push eax-tn)</font>
<font color="#009900">+      (inst mov eax-tn (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+      (inst cmp (make-ea :dword</font>
<font color="#009900">+                         :base eax-tn</font>
<font color="#009900">+                         :disp (* thread-stepping-slot n-word-bytes)) nil-value)</font>
<font color="#009900">+      (inst pop eax-tn))</font>
<font color="#009900">+    #!-(and win32 sb-thread)</font>
     (inst cmp (make-ea :dword
                        :disp (* thread-stepping-slot n-word-bytes))
           nil-value :fs))
diff --git a/src/compiler/x86/cell.lisp b/src/compiler/x86/cell.lisp
index bb82a39..ca7f96d 100644
<font color="#FF6600">--- a/src/compiler/x86/cell.lisp</font>
<font color="#009900">+++ b/src/compiler/x86/cell.lisp</font>
<font color="#0000FF">@@ -56,7 +56,7 @@</font>
          (new :scs (descriptor-reg any-reg)))
   (:temporary (:sc descriptor-reg :offset eax-offset) eax)
   #!+sb-thread
<font color="#FF6600">-  (:temporary (:sc descriptor-reg) tls)</font>
<font color="#009900">+  (:temporary (:sc descriptor-reg) tls #!+win32 tmp)</font>
   (:results (result :scs (descriptor-reg any-reg)))
   (:policy :fast-safe)
   (:vop-var vop)
<font color="#0000FF">@@ -71,6 +71,11 @@</font>
       (progn
         (loadw tls symbol symbol-tls-index-slot other-pointer-lowtag)
         ;; Thread-local area, no LOCK needed.
<font color="#009900">+        #!+win32</font>
<font color="#009900">+        (progn</font>
<font color="#009900">+          (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+          (inst cmpxchg (make-ea :dword :base tmp :index tls) new))</font>
<font color="#009900">+        #!-win32</font>
         (inst cmpxchg (make-ea :dword :base tls) new :fs)
         (inst cmp eax no-tls-value-marker-widetag)
         (inst jmp :ne check)
<font color="#0000FF">@@ -110,13 +115,21 @@</font>
   (define-vop (set)
     (:args (symbol :scs (descriptor-reg))
            (value :scs (descriptor-reg any-reg)))
<font color="#FF6600">-    (:temporary (:sc descriptor-reg) tls)</font>
<font color="#009900">+    (:temporary (:sc descriptor-reg) tls #!+win32 tmp)</font>
     (:generator 4
       (let ((global-val (gen-label))
             (done (gen-label)))
         (loadw tls symbol symbol-tls-index-slot other-pointer-lowtag)
<font color="#009900">+        #!+win32</font>
<font color="#009900">+        (progn</font>
<font color="#009900">+          (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+          (inst cmp (make-ea :dword :base tmp :index tls) no-tls-value-marker-widetag))</font>
<font color="#009900">+        #!-win32</font>
         (inst cmp (make-ea :dword :base tls) no-tls-value-marker-widetag :fs)
         (inst jmp :z global-val)
<font color="#009900">+        #!+win32</font>
<font color="#009900">+        (inst mov (make-ea :dword :base tmp :index tls) value)</font>
<font color="#009900">+        #!-win32</font>
         (inst mov (make-ea :dword :base tls) value :fs)
         (inst jmp done)
         (emit-label global-val)
<font color="#0000FF">@@ -130,6 +143,8 @@</font>
     (:policy :fast-safe)
     (:args (object :scs (descriptor-reg) :to (:result 1)))
     (:results (value :scs (descriptor-reg any-reg)))
<font color="#009900">+    #!+win32</font>
<font color="#009900">+    (:temporary (:sc descriptor-reg) tmp)</font>
     (:vop-var vop)
     (:save-p :compute-only)
     (:generator 9
<font color="#0000FF">@@ -137,6 +152,11 @@</font>
              (err-lab (generate-error-code vop 'unbound-symbol-error object))
              (ret-lab (gen-label)))
         (loadw value object symbol-tls-index-slot other-pointer-lowtag)
<font color="#009900">+        #!+win32</font>
<font color="#009900">+        (progn</font>
<font color="#009900">+          (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+          (inst mov value (make-ea :dword :base tmp :index value)))</font>
<font color="#009900">+        #!-win32</font>
         (inst mov value (make-ea :dword :base value) :fs)
         (inst cmp value no-tls-value-marker-widetag)
         (inst jmp :ne check-unbound-label)
<font color="#0000FF">@@ -152,11 +172,18 @@</font>
     ;; the meaning of FAST-SYMBOL-VALUE is "do not signal an error if
     ;; unbound", which is used in the implementation of COPY-SYMBOL.  --
     ;; CSR, 2003-04-22
<font color="#009900">+    #!+win32</font>
<font color="#009900">+    (:temporary (:sc descriptor-reg) tmp)</font>
     (:policy :fast)
     (:translate symbol-value)
     (:generator 8
       (let ((ret-lab (gen-label)))
         (loadw value object symbol-tls-index-slot other-pointer-lowtag)
<font color="#009900">+        #!+win32</font>
<font color="#009900">+        (progn</font>
<font color="#009900">+          (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+          (inst mov value (make-ea :dword :base tmp :index value)))</font>
<font color="#009900">+        #!-win32</font>
         (inst mov value (make-ea :dword :base value) :fs)
         (inst cmp value no-tls-value-marker-widetag)
         (inst jmp :ne ret-lab)
<font color="#0000FF">@@ -178,9 +205,16 @@</font>
   (:args (object :scs (descriptor-reg)))
   (:conditional :ne)
   (:temporary (:sc descriptor-reg #+nil(:from (:argument 0))) value)
<font color="#009900">+  #!+win32</font>
<font color="#009900">+  (:temporary (:sc descriptor-reg) tmp)</font>
   (:generator 9
     (let ((check-unbound-label (gen-label)))
       (loadw value object symbol-tls-index-slot other-pointer-lowtag)
<font color="#009900">+      #!+win32</font>
<font color="#009900">+      (progn</font>
<font color="#009900">+        (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+        (inst mov value (make-ea :dword :base tmp :index value)))</font>
<font color="#009900">+      #!-win32</font>
       (inst mov value (make-ea :dword :base value) :fs)
       (inst cmp value no-tls-value-marker-widetag)
       (inst jmp :ne check-unbound-label)
<font color="#0000FF">@@ -278,6 +312,8 @@</font>
   (:args (val :scs (any-reg descriptor-reg))
          (symbol :scs (descriptor-reg)))
   (:temporary (:sc unsigned-reg) tls-index bsp)
<font color="#009900">+  #!+win32</font>
<font color="#009900">+  (:temporary (:sc descriptor-reg) tmp)</font>
   (:generator 10
     (let ((tls-index-valid (gen-label)))
       (load-binding-stack-pointer bsp)
<font color="#0000FF">@@ -297,9 +333,17 @@</font>
                     (#.esi-offset 'alloc-tls-index-in-esi))
                   :assembly-routine))
       (emit-label tls-index-valid)
<font color="#009900">+      #!+win32</font>
<font color="#009900">+      (progn</font>
<font color="#009900">+        (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+        (inst push (make-ea :dword :base tmp :index tls-index)))</font>
<font color="#009900">+      #!-win32</font>
       (inst push (make-ea :dword :base tls-index) :fs)
       (popw bsp (- binding-value-slot binding-size))
       (storew symbol bsp (- binding-symbol-slot binding-size))
<font color="#009900">+      #!+win32</font>
<font color="#009900">+      (inst mov (make-ea :dword :base tmp :index tls-index) val)</font>
<font color="#009900">+      #!-win32</font>
       (inst mov (make-ea :dword :base tls-index) val :fs))))
 
 #!-sb-thread
<font color="#0000FF">@@ -319,6 +363,8 @@</font>
 #!+sb-thread
 (define-vop (unbind)
   (:temporary (:sc unsigned-reg) temp bsp tls-index)
<font color="#009900">+  #!+win32</font>
<font color="#009900">+  (:temporary (:sc descriptor-reg) tmp)</font>
   (:generator 0
     (load-binding-stack-pointer bsp)
     ;; Load SYMBOL from stack, and get the TLS-INDEX.
<font color="#0000FF">@@ -326,6 +372,11 @@</font>
     (loadw tls-index temp symbol-tls-index-slot other-pointer-lowtag)
     ;; Load VALUE from stack, then restore it to the TLS area.
     (loadw temp bsp (- binding-value-slot binding-size))
<font color="#009900">+    #!+win32</font>
<font color="#009900">+    (progn</font>
<font color="#009900">+      (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+      (inst mov (make-ea :dword :base tmp :index tls-index) temp))</font>
<font color="#009900">+    #!-win32</font>
     (inst mov (make-ea :dword :base tls-index) temp :fs)
     ;; Zero out the stack.
     (storew 0 bsp (- binding-symbol-slot binding-size))
<font color="#0000FF">@@ -350,6 +401,8 @@</font>
 (define-vop (unbind-to-here)
   (:args (where :scs (descriptor-reg any-reg)))
   (:temporary (:sc unsigned-reg) symbol value bsp #!+sb-thread tls-index)
<font color="#009900">+  #!+(and sb-thread win32)</font>
<font color="#009900">+  (:temporary (:sc descriptor-reg) tmp)</font>
   (:generator 0
     (load-binding-stack-pointer bsp)
     (inst cmp where bsp)
<font color="#0000FF">@@ -367,7 +420,12 @@</font>
 
     #!+sb-thread (loadw
                   tls-index symbol symbol-tls-index-slot other-pointer-lowtag)
<font color="#FF6600">-    #!+sb-thread (inst mov (make-ea :dword :base tls-index) value :fs)</font>
<font color="#009900">+    #!+(and sb-thread win32)</font>
<font color="#009900">+    (progn</font>
<font color="#009900">+      (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+      (inst mov (make-ea :dword :base tmp :index tls-index) value))</font>
<font color="#009900">+    #!+(and sb-thread (not win32))</font>
<font color="#009900">+    (inst mov (make-ea :dword :base tls-index) value :fs)</font>
     (storew 0 bsp (- binding-symbol-slot binding-size))
 
     SKIP
diff --git a/src/compiler/x86/macros.lisp b/src/compiler/x86/macros.lisp
index 18251b5..eb4f9e9 100644
<font color="#FF6600">--- a/src/compiler/x86/macros.lisp</font>
<font color="#009900">+++ b/src/compiler/x86/macros.lisp</font>
<font color="#0000FF">@@ -112,6 +112,11 @@</font>
 (defmacro load-tl-symbol-value (reg symbol)
   `(progn
     (inst mov ,reg (make-ea-for-symbol-tls-index ,symbol))
<font color="#009900">+    #!+win32</font>
<font color="#009900">+    (progn</font>
<font color="#009900">+      (inst add ,reg (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+      (inst mov ,reg (make-ea :dword :base ,reg)))</font>
<font color="#009900">+    #!-win32</font>
     (inst mov ,reg (make-ea :dword :base ,reg) :fs)))
 #!-sb-thread
 (defmacro load-tl-symbol-value (reg symbol) `(load-symbol-value ,reg ,symbol))
<font color="#0000FF">@@ -120,6 +125,11 @@</font>
 (defmacro store-tl-symbol-value (reg symbol temp)
   `(progn
     (inst mov ,temp (make-ea-for-symbol-tls-index ,symbol))
<font color="#009900">+    #!+win32</font>
<font color="#009900">+    (progn</font>
<font color="#009900">+      (inst add ,temp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+      (inst mov (make-ea :dword :base ,temp) ,reg))</font>
<font color="#009900">+    #!-win32</font>
     (inst mov (make-ea :dword :base ,temp) ,reg :fs)))
 #!-sb-thread
 (defmacro store-tl-symbol-value (reg symbol temp)
<font color="#0000FF">@@ -129,6 +139,13 @@</font>
 (defmacro load-binding-stack-pointer (reg)
   #!+sb-thread
   `(progn
<font color="#009900">+     #!+win32</font>
<font color="#009900">+     (progn</font>
<font color="#009900">+       (inst mov ,reg (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+       (inst mov ,reg (make-ea :dword</font>
<font color="#009900">+                               :base ,reg</font>
<font color="#009900">+                               :disp (* 4 thread-binding-stack-pointer-slot))))</font>
<font color="#009900">+     #!-win32</font>
      (inst mov ,reg (make-ea :dword
                              :disp (* 4 thread-binding-stack-pointer-slot))
            :fs))
<font color="#0000FF">@@ -138,6 +155,14 @@</font>
 (defmacro store-binding-stack-pointer (reg)
   #!+sb-thread
   `(progn
<font color="#009900">+     #!+win32</font>
<font color="#009900">+     (progn</font>
<font color="#009900">+       (inst push eax-tn)</font>
<font color="#009900">+       (inst push ,reg)</font>
<font color="#009900">+       (inst mov eax-tn (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+       (inst pop (make-ea :dword :base eax-tn :disp (* 4 thread-binding-stack-pointer-slot)))</font>
<font color="#009900">+       (inst pop eax-tn))</font>
<font color="#009900">+     #!-win32</font>
      (inst mov (make-ea :dword
                         :disp (* 4 thread-binding-stack-pointer-slot))
            ,reg :fs))
<font color="#0000FF">@@ -265,6 +290,10 @@</font>
     (dynamic-extent
      (allocation-dynamic-extent alloc-tn size lowtag))
     ((or (null inline) (policy inline (&gt;= speed space)))
<font color="#009900">+     ;; FIXME Win32</font>
<font color="#009900">+     #!+win32</font>
<font color="#009900">+     (allocation-notinline alloc-tn size)</font>
<font color="#009900">+     #!-win32</font>
      (allocation-inline alloc-tn size))
     (t
      (allocation-notinline alloc-tn size)))
<font color="#0000FF">@@ -354,22 +383,45 @@</font>
 ;;; pa section.
 #!+sb-thread
 (defmacro %clear-pseudo-atomic ()
<font color="#009900">+  #!+win32</font>
<font color="#009900">+  '(progn</font>
<font color="#009900">+    (inst push eax-tn)</font>
<font color="#009900">+    (inst mov eax-tn (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+    (inst mov (make-ea :dword :base eax-tn :disp (* 4 thread-pseudo-atomic-bits-slot)) 0)</font>
<font color="#009900">+    (inst pop eax-tn))</font>
<font color="#009900">+  #!-win32</font>
   '(inst mov (make-ea :dword :disp (* 4 thread-pseudo-atomic-bits-slot)) 0 :fs))
 
 #!+sb-thread
 (defmacro pseudo-atomic (&amp;rest forms)
   (with-unique-names (label)
     `(let ((,label (gen-label)))
<font color="#009900">+       #!+win32</font>
<font color="#009900">+       (progn</font>
<font color="#009900">+         (inst push eax-tn)</font>
<font color="#009900">+         (inst mov eax-tn (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+         (inst mov (make-ea :dword :base eax-tn :disp (* 4 thread-pseudo-atomic-bits-slot)) ebp-tn)</font>
<font color="#009900">+         (inst pop eax-tn))</font>
<font color="#009900">+       #!-win32</font>
        (inst mov (make-ea :dword :disp (* 4 thread-pseudo-atomic-bits-slot))
              ebp-tn :fs)
        ,@forms
<font color="#009900">+       #!+win32</font>
<font color="#009900">+       (progn</font>
<font color="#009900">+         (inst push eax-tn)</font>
<font color="#009900">+         (inst mov eax-tn (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+         (inst xor (make-ea :dword :base eax-tn :disp (* 4 thread-pseudo-atomic-bits-slot)) ebp-tn)</font>
<font color="#009900">+         (inst pop eax-tn))</font>
<font color="#009900">+       #!-win32</font>
        (inst xor (make-ea :dword :disp (* 4 thread-pseudo-atomic-bits-slot))
              ebp-tn :fs)
        (inst jmp :z ,label)
        ;; if PAI was set, interrupts were disabled at the same time
        ;; using the process signal mask.
        (inst break pending-interrupt-trap)
<font color="#FF6600">-       (emit-label ,label))))</font>
<font color="#009900">+       (emit-label ,label)</font>
<font color="#009900">+       #!+win32</font>
<font color="#009900">+       (inst test eax-tn (make-ea :dword :disp sb!vm::gc-safepoint-page-addr)))))</font>
 
 #!-sb-thread
 (defmacro pseudo-atomic (&amp;rest forms)
<font color="#0000FF">@@ -566,3 +618,40 @@ collection."</font>
                            `(touch-object ,pin))
                          pins)))))
       `(progn ,@body)))
<font color="#009900">+</font>
<font color="#009900">+;;; Safepoints stuff</font>
<font color="#009900">+</font>
<font color="#009900">+#!+ (and sb-thread win32)</font>
<font color="#009900">+(progn</font>
<font color="#009900">+  (defun enter-safe-region-instructions ()</font>
<font color="#009900">+    (inst pusha)</font>
<font color="#009900">+    (inst call (make-fixup "gc_enter_safe_region" :foreign))</font>
<font color="#009900">+    (inst popa))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun enter-unsafe-region-instructions ()</font>
<font color="#009900">+    (inst pusha)</font>
<font color="#009900">+    (inst call (make-fixup "gc_enter_unsafe_region" :foreign))</font>
<font color="#009900">+    (inst popa))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun leave-region-instructions ()</font>
<font color="#009900">+    (inst pusha)</font>
<font color="#009900">+    (inst call (make-fixup "gc_leave_region" :foreign))</font>
<font color="#009900">+    (inst popa))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun enter-safe-region-instructions/no-fixup ()</font>
<font color="#009900">+    (inst pusha)</font>
<font color="#009900">+    (inst mov eax-tn (foreign-symbol-address "gc_enter_safe_region"))</font>
<font color="#009900">+    (inst call eax-tn)</font>
<font color="#009900">+    (inst popa))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun enter-unsafe-region-instructions/no-fixup ()</font>
<font color="#009900">+    (inst pusha)</font>
<font color="#009900">+    (inst mov eax-tn (foreign-symbol-address "gc_enter_unsafe_region"))</font>
<font color="#009900">+    (inst call eax-tn)</font>
<font color="#009900">+    (inst popa))</font>
<font color="#009900">+</font>
<font color="#009900">+  (defun leave-region-instructions/no-fixup ()</font>
<font color="#009900">+    (inst pusha)</font>
<font color="#009900">+    (inst mov eax-tn (foreign-symbol-address "gc_leave_region"))</font>
<font color="#009900">+    (inst call eax-tn)</font>
<font color="#009900">+    (inst popa)))</font>
diff --git a/src/compiler/x86/parms.lisp b/src/compiler/x86/parms.lisp
index 8bf3674..9cb2d99 100644
<font color="#FF6600">--- a/src/compiler/x86/parms.lisp</font>
<font color="#009900">+++ b/src/compiler/x86/parms.lisp</font>
<font color="#0000FF">@@ -186,6 +186,8 @@</font>
 
 #!+win32
 (progn
<font color="#009900">+  #!+sb-thread</font>
<font color="#009900">+  (def!constant gc-safepoint-page-addr #x21000000)</font>
 
   (def!constant read-only-space-start #x22000000)
   (def!constant read-only-space-end   #x220ff000)
<font color="#0000FF">@@ -385,3 +387,5 @@</font>
 ;;; FIXME: Is this used? Delete it or document it.
 ;;; cf the sparc PARMS.LISP
 (defparameter *assembly-unit-length* 8)
<font color="#009900">+</font>
<font color="#009900">+(defconstant +win32-tib-arbitrary-field-offset+ #.(+ #xE10 (* 4 63)))</font>
diff --git a/src/compiler/x86/system.lisp b/src/compiler/x86/system.lisp
index fd14fbf..d6c0503 100644
<font color="#FF6600">--- a/src/compiler/x86/system.lisp</font>
<font color="#009900">+++ b/src/compiler/x86/system.lisp</font>
<font color="#0000FF">@@ -254,6 +254,11 @@</font>
   (:generator 1
     (inst break pending-interrupt-trap)))
 
<font color="#009900">+#!+(and sb-thread win32)</font>
<font color="#009900">+(define-vop (insert-gc-safepoint)</font>
<font color="#009900">+  (:generator 0</font>
<font color="#009900">+    (inst test eax-tn (make-ea :dword :disp sb!vm::gc-safepoint-page-addr))))</font>
<font color="#009900">+</font>
 #!+sb-thread
 (defknown current-thread-offset-sap ((unsigned-byte 32))
   system-area-pointer (flushable))
<font color="#0000FF">@@ -264,9 +269,16 @@</font>
   (:result-types system-area-pointer)
   (:translate current-thread-offset-sap)
   (:args (n :scs (unsigned-reg) :target sap))
<font color="#009900">+  #!+win32</font>
<font color="#009900">+  (:temporary (:sc unsigned-reg) tmp)</font>
   (:arg-types unsigned-num)
   (:policy :fast-safe)
   (:generator 2
<font color="#009900">+    #!+win32</font>
<font color="#009900">+    (progn</font>
<font color="#009900">+      (inst mov tmp (make-ea :dword :disp +win32-tib-arbitrary-field-offset+) :fs)</font>
<font color="#009900">+      (inst mov sap (make-ea :dword :base tmp :disp 0 :index n :scale 4)))</font>
<font color="#009900">+    #!-win32</font>
     (inst mov sap (make-ea :dword :disp 0 :index n :scale 4) :fs)))
 
 (define-vop (halt)
diff --git a/src/runtime/Config.x86-win32 b/src/runtime/Config.x86-win32
index b341808..2d2aef9 100644
<font color="#FF6600">--- a/src/runtime/Config.x86-win32</font>
<font color="#009900">+++ b/src/runtime/Config.x86-win32</font>
<font color="#0000FF">@@ -12,7 +12,7 @@ TARGET=sbcl.exe</font>
 ASSEM_SRC = x86-assem.S
 ARCH_SRC = x86-arch.c
 
<font color="#FF6600">-OS_SRC = win32-os.c x86-win32-os.c os-common.c</font>
<font color="#009900">+OS_SRC = win32-os.c x86-win32-os.c os-common.c pthreads_win32.c</font>
 # The "--Wl,--export-dynamic" flags are here to help people
 # experimenting with callbacks from C to SBCL, by allowing linkage to
 # SBCL src/runtime/*.c symbols from C. Work on this is good, but it's
diff --git a/src/runtime/arch.h b/src/runtime/arch.h
index f50e0d4..9678491 100644
<font color="#FF6600">--- a/src/runtime/arch.h</font>
<font color="#009900">+++ b/src/runtime/arch.h</font>
<font color="#0000FF">@@ -13,7 +13,6 @@</font>
 #define __ARCH_H__
 
 #include "os.h"
<font color="#FF6600">-#include "signal.h"</font>
 #include "thread.h"
 
 /* Do anything we need to do when starting up the runtime environment
diff --git a/src/runtime/backtrace.c b/src/runtime/backtrace.c
index 1d9b506..e8ddb43 100644
<font color="#FF6600">--- a/src/runtime/backtrace.c</font>
<font color="#009900">+++ b/src/runtime/backtrace.c</font>
<font color="#0000FF">@@ -14,7 +14,6 @@</font>
  */
 
 #include &lt;stdio.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 #include "sbcl.h"
 #include "runtime.h"
 #include "globals.h"
<font color="#0000FF">@@ -500,12 +499,14 @@ describe_thread_state(void)</font>
     sigset_t mask;
     struct thread *thread = arch_os_get_current_thread();
     struct interrupt_data *data = thread-&gt;interrupt_data;
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     get_current_sigmask(&amp;mask);
     printf("Signal mask:\n");
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
     printf(" SIGALRM = %d\n", sigismember(&amp;mask, SIGALRM));
     printf(" SIGINT = %d\n", sigismember(&amp;mask, SIGINT));
     printf(" SIGPROF = %d\n", sigismember(&amp;mask, SIGPROF));
<font color="#009900">+#endif</font>
 #ifdef SIG_STOP_FOR_GC
     printf(" SIG_STOP_FOR_GC = %d\n", sigismember(&amp;mask, SIG_STOP_FOR_GC));
 #endif
diff --git a/src/runtime/breakpoint.c b/src/runtime/breakpoint.c
index a325693..a1dd10d 100644
<font color="#FF6600">--- a/src/runtime/breakpoint.c</font>
<font color="#009900">+++ b/src/runtime/breakpoint.c</font>
<font color="#0000FF">@@ -10,7 +10,6 @@</font>
  */
 
 #include &lt;stdio.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 
 #include "sbcl.h"
 #include "runtime.h"
<font color="#0000FF">@@ -134,7 +133,7 @@ void handle_breakpoint(os_context_t *context)</font>
     context_sap = alloc_sap(context);
     code = find_code(context);
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     /* Don't disallow recursive breakpoint traps. Otherwise, we can't
      * use debugger breakpoints anywhere in here. */
     thread_sigmask(SIG_SETMASK, os_context_sigmask_addr(context), 0);
<font color="#0000FF">@@ -160,7 +159,7 @@ void *handle_fun_end_breakpoint(os_context_t *context)</font>
     code = find_code(context);
     codeptr = (struct code *)native_pointer(code);
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     /* Don't disallow recursive breakpoint traps. Otherwise, we can't
      * use debugger breakpoints anywhere in here. */
     thread_sigmask(SIG_SETMASK, os_context_sigmask_addr(context), 0);
<font color="#0000FF">@@ -199,7 +198,7 @@ handle_single_step_trap (os_context_t *context, int kind, int register_offset)</font>
 {
     fake_foreign_function_call(context);
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     thread_sigmask(SIG_SETMASK, os_context_sigmask_addr(context), 0);
 #endif
 
diff --git a/src/runtime/cheneygc.c b/src/runtime/cheneygc.c
index 10b4d4a..a28cf73 100644
<font color="#FF6600">--- a/src/runtime/cheneygc.c</font>
<font color="#009900">+++ b/src/runtime/cheneygc.c</font>
<font color="#0000FF">@@ -16,7 +16,6 @@</font>
 #include &lt;stdio.h&gt;
 #include &lt;sys/time.h&gt;
 #include &lt;sys/resource.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 #include "sbcl.h"
 #include "runtime.h"
 #include "os.h"
diff --git a/src/runtime/dynbind.c b/src/runtime/dynbind.c
index 1d62ee0..124152f 100644
<font color="#FF6600">--- a/src/runtime/dynbind.c</font>
<font color="#009900">+++ b/src/runtime/dynbind.c</font>
<font color="#0000FF">@@ -83,6 +83,28 @@ unbind(void *th)</font>
 }
 
 void
<font color="#009900">+unbind_variable(lispobj name, void *th)</font>
<font color="#009900">+{</font>
<font color="#009900">+    struct thread *thread=(struct thread *)th;</font>
<font color="#009900">+    struct binding *binding;</font>
<font color="#009900">+    lispobj symbol;</font>
<font color="#009900">+</font>
<font color="#009900">+    binding = ((struct binding *)get_binding_stack_pointer(thread)) - 1;</font>
<font color="#009900">+</font>
<font color="#009900">+    symbol = binding-&gt;symbol;</font>
<font color="#009900">+    </font>
<font color="#009900">+    if (symbol != name)</font>
<font color="#009900">+      lose("unbind_variable, 0x%p != 0x%p", symbol, name);</font>
<font color="#009900">+</font>
<font color="#009900">+    SetTlSymbolValue(symbol, binding-&gt;value,thread);</font>
<font color="#009900">+</font>
<font color="#009900">+    binding-&gt;symbol = 0;</font>
<font color="#009900">+    binding-&gt;value = 0;</font>
<font color="#009900">+</font>
<font color="#009900">+    set_binding_stack_pointer(thread,binding);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void</font>
 unbind_to_here(lispobj *bsp,void *th)
 {
     struct thread *thread=(struct thread *)th;
diff --git a/src/runtime/dynbind.h b/src/runtime/dynbind.h
index 41aa9eb..526b02d 100644
<font color="#FF6600">--- a/src/runtime/dynbind.h</font>
<font color="#009900">+++ b/src/runtime/dynbind.h</font>
<font color="#0000FF">@@ -14,6 +14,7 @@</font>
 
 extern void bind_variable(lispobj symbol, lispobj value,void *thread);
 extern void unbind(void *thread);
<font color="#009900">+extern void unbind_variable(lispobj name, void *thread);</font>
 extern void unbind_to_here(lispobj *bsp,void *thread);
 
 #endif
diff --git a/src/runtime/gc-common.c b/src/runtime/gc-common.c
old mode 100644
new mode 100755
index 95b5c3b..66be64f
<font color="#FF6600">--- a/src/runtime/gc-common.c</font>
<font color="#009900">+++ b/src/runtime/gc-common.c</font>
<font color="#0000FF">@@ -26,7 +26,6 @@</font>
  */
 
 #include &lt;stdio.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 #include &lt;string.h&gt;
 #include "sbcl.h"
 #include "runtime.h"
<font color="#0000FF">@@ -2403,6 +2402,8 @@ gc_search_space(lispobj *start, size_t words, lispobj *pointer)</font>
     return (NULL);
 }
 
<font color="#009900">+#include "dynbind.h"</font>
<font color="#009900">+</font>
 boolean
 maybe_gc(os_context_t *context)
 {
<font color="#0000FF">@@ -2432,7 +2433,7 @@ maybe_gc(os_context_t *context)</font>
      * A kludgy alternative is to propagate the sigmask change to the
      * outer context.
      */
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     check_gc_signals_unblocked_or_lose(os_context_sigmask_addr(context));
     unblock_gc_signals(0, 0);
 #endif
<font color="#0000FF">@@ -2453,7 +2454,7 @@ maybe_gc(os_context_t *context)</font>
          * here. */
         ((SymbolValue(INTERRUPTS_ENABLED,thread) != NIL) ||
          (SymbolValue(ALLOW_WITH_INTERRUPTS,thread) != NIL))) {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
         sigset_t *context_sigmask = os_context_sigmask_addr(context);
         if (!deferrables_blocked_p(context_sigmask)) {
             thread_sigmask(SIG_SETMASK, context_sigmask, 0);
<font color="#0000FF">@@ -2461,7 +2462,7 @@ maybe_gc(os_context_t *context)</font>
 #endif
             FSHOW((stderr, "/maybe_gc: calling POST_GC\n"));
             funcall0(StaticSymbolFunction(POST_GC));
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
         } else {
             FSHOW((stderr, "/maybe_gc: punting on POST_GC due to blockage\n"));
         }
diff --git a/src/runtime/gencgc.c b/src/runtime/gencgc.c
old mode 100644
new mode 100755
index f3c3aab..483544f
<font color="#FF6600">--- a/src/runtime/gencgc.c</font>
<font color="#009900">+++ b/src/runtime/gencgc.c</font>
<font color="#0000FF">@@ -26,7 +26,6 @@</font>
 
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 #include &lt;errno.h&gt;
 #include &lt;string.h&gt;
 #include "sbcl.h"
<font color="#0000FF">@@ -3973,7 +3972,40 @@ garbage_collect_generation(generation_index_t generation, int raise)</font>
                 /* Somebody is going to burn in hell for this, but casting
                  * it in two steps shuts gcc up about strict aliasing. */
                 esp = (void **)((void *)&amp;raise);
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+                {</font>
<font color="#009900">+                  CONTEXT context;</font>
<font color="#009900">+                  os_context_t ctx;</font>
<font color="#009900">+                  if (!pthread_np_get_thread_context(th-&gt;os_thread, &amp;context))</font>
<font color="#009900">+                    lose("Unable to get thread context for thread 0x%x\n", (int)th-&gt;os_thread);</font>
<font color="#009900">+                  ctx.win32_context = &amp;context;</font>
<font color="#009900">+                  preserve_context_registers(&amp;ctx);</font>
<font color="#009900">+</font>
<font color="#009900">+                  pthread_mutex_lock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+                  for (i = 0; i &lt; th-&gt;interrupt_data-&gt;win32_data.interrupts_count; ++i) {</font>
<font color="#009900">+                    preserve_pointer((void*)th-&gt;interrupt_data-&gt;win32_data.interrupts[i]);</font>
<font color="#009900">+                  }</font>
<font color="#009900">+                  pthread_mutex_unlock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+                }</font>
<font color="#009900">+#endif</font>
             } else {
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+                CONTEXT context;</font>
<font color="#009900">+                os_context_t ctx;</font>
<font color="#009900">+                pthread_np_suspend(th-&gt;os_thread);</font>
<font color="#009900">+                if (!pthread_np_get_thread_context(th-&gt;os_thread, &amp;context))</font>
<font color="#009900">+                  lose("Unable to get thread context for thread 0x%x\n", (int)th-&gt;os_thread);</font>
<font color="#009900">+                ctx.win32_context = &amp;context;</font>
<font color="#009900">+                preserve_context_registers(&amp;ctx);</font>
<font color="#009900">+                pthread_np_resume(th-&gt;os_thread);</font>
<font color="#009900">+                esp = (void**)context.Esp;</font>
<font color="#009900">+                </font>
<font color="#009900">+                pthread_mutex_lock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+                for (i = 0; i &lt; th-&gt;interrupt_data-&gt;win32_data.interrupts_count; ++i) {</font>
<font color="#009900">+                  preserve_pointer((void*)th-&gt;interrupt_data-&gt;win32_data.interrupts[i]);</font>
<font color="#009900">+                }</font>
<font color="#009900">+                pthread_mutex_unlock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+#else</font>
                 void **esp1;
                 free=fixnum_value(SymbolValue(FREE_INTERRUPT_CONTEXT_INDEX,th));
                 for(i=free-1;i&gt;=0;i--) {
<font color="#0000FF">@@ -3985,6 +4017,7 @@ garbage_collect_generation(generation_index_t generation, int raise)</font>
                         preserve_context_registers(c);
                     }
                 }
<font color="#009900">+#endif</font>
             }
 #else
             esp = (void **)((void *)&amp;raise);
<font color="#0000FF">@@ -4664,8 +4697,10 @@ general_alloc_internal(long nbytes, int page_type_flag, struct alloc_region *reg</font>
                         (context ? os_context_sigmask_addr(context) : NULL);
                 }
 #else
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
                 maybe_save_gc_mask_and_block_deferrables(NULL);
 #endif
<font color="#009900">+#endif</font>
             }
         }
     }
diff --git a/src/runtime/interr.c b/src/runtime/interr.c
index 2187fd8..f2625db 100644
<font color="#FF6600">--- a/src/runtime/interr.c</font>
<font color="#009900">+++ b/src/runtime/interr.c</font>
<font color="#0000FF">@@ -19,7 +19,6 @@</font>
 
 #include "sbcl.h"
 #include "arch.h"
<font color="#FF6600">-#include "signal.h"</font>
 
 #include "runtime.h"
 #include "interr.h"
<font color="#0000FF">@@ -68,6 +67,10 @@ call_lossage_handler() never_returns;</font>
 static inline void
 call_lossage_handler()
 {
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    void lisp_backtrace(int frames);</font>
<font color="#009900">+    lisp_backtrace(100);</font>
<font color="#009900">+#endif</font>
     lossage_handler();
     fprintf(stderr, "Argh! lossage_handler() returned, total confusion..\n");
     exit(1);
<font color="#0000FF">@@ -77,6 +80,9 @@ void</font>
 lose(char *fmt, ...)
 {
     va_list ap;
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("lose %s", fmt);</font>
<font color="#009900">+#endif</font>
     /* Block signals to prevent other threads, timers and such from
      * interfering. If only all threads could be stopped somehow. */
     block_blockable_signals(0, 0);
<font color="#0000FF">@@ -95,7 +101,7 @@ void</font>
 corruption_warning_and_maybe_lose(char *fmt, ...)
 {
     va_list ap;
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     sigset_t oldset;
     block_blockable_signals(0, &amp;oldset);
 #endif
<font color="#0000FF">@@ -111,7 +117,7 @@ corruption_warning_and_maybe_lose(char *fmt, ...)</font>
     fflush(stderr);
     if (lose_on_corruption_p)
         call_lossage_handler();
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     else
         thread_sigmask(SIG_SETMASK,&amp;oldset,0);
 #endif
diff --git a/src/runtime/interrupt.c b/src/runtime/interrupt.c
index ea0880f..bb9563b 100644
<font color="#FF6600">--- a/src/runtime/interrupt.c</font>
<font color="#009900">+++ b/src/runtime/interrupt.c</font>
<font color="#0000FF">@@ -45,7 +45,7 @@</font>
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
 #include &lt;sys/types.h&gt;
 #ifndef LISP_FEATURE_WIN32
 #include &lt;sys/wait.h&gt;
<font color="#0000FF">@@ -102,7 +102,7 @@ union interrupt_handler interrupt_handlers[NSIG];</font>
  * work for SIGSEGV and similar. It is good enough for timers, and
  * maybe all deferrables. */
 
<font color="#FF6600">-#ifdef LISP_FEATURE_SB_THREAD</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD) &amp;&amp; !defined(LISP_FEATURE_WIN32)</font>
 static void
 add_handled_signals(sigset_t *sigset)
 {
<font color="#0000FF">@@ -121,7 +121,7 @@ void block_signals(sigset_t *what, sigset_t *where, sigset_t *old);</font>
 static boolean
 maybe_resignal_to_lisp_thread(int signal, os_context_t *context)
 {
<font color="#FF6600">-#ifdef LISP_FEATURE_SB_THREAD</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD) &amp;&amp; !defined(LISP_FEATURE_WIN32)</font>
     if (!pthread_getspecific(lisp_thread)) {
         if (!(sigismember(&amp;deferrable_sigset,signal))) {
             corruption_warning_and_maybe_lose
<font color="#0000FF">@@ -175,7 +175,7 @@ maybe_resignal_to_lisp_thread(int signal, os_context_t *context)</font>
 
 static void run_deferred_handler(struct interrupt_data *data,
                                  os_context_t *context);
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
 static void store_signal_data_for_later (struct interrupt_data *data,
                                          void *handler, int signal,
                                          siginfo_t *info,
<font color="#0000FF">@@ -240,7 +240,7 @@ boolean</font>
 all_signals_blocked_p(sigset_t *sigset, sigset_t *sigset2,
                                 const char *name)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     int i;
     boolean has_blocked = 0, has_unblocked = 0;
     sigset_t current;
<font color="#0000FF">@@ -314,7 +314,7 @@ sigset_t gc_sigset;</font>
 
 #endif
 
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
 boolean
 deferrables_blocked_p(sigset_t *sigset)
 {
<font color="#0000FF">@@ -325,7 +325,7 @@ deferrables_blocked_p(sigset_t *sigset)</font>
 void
 check_deferrables_unblocked_or_lose(sigset_t *sigset)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (deferrables_blocked_p(sigset))
         lose("deferrables blocked\n");
 #endif
<font color="#0000FF">@@ -334,13 +334,13 @@ check_deferrables_unblocked_or_lose(sigset_t *sigset)</font>
 void
 check_deferrables_blocked_or_lose(sigset_t *sigset)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (!deferrables_blocked_p(sigset))
         lose("deferrables unblocked\n");
 #endif
 }
 
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
 boolean
 blockables_blocked_p(sigset_t *sigset)
 {
<font color="#0000FF">@@ -351,7 +351,7 @@ blockables_blocked_p(sigset_t *sigset)</font>
 void
 check_blockables_unblocked_or_lose(sigset_t *sigset)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (blockables_blocked_p(sigset))
         lose("blockables blocked\n");
 #endif
<font color="#0000FF">@@ -360,13 +360,13 @@ check_blockables_unblocked_or_lose(sigset_t *sigset)</font>
 void
 check_blockables_blocked_or_lose(sigset_t *sigset)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (!blockables_blocked_p(sigset))
         lose("blockables unblocked\n");
 #endif
 }
 
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
 boolean
 gc_signals_blocked_p(sigset_t *sigset)
 {
<font color="#0000FF">@@ -377,7 +377,7 @@ gc_signals_blocked_p(sigset_t *sigset)</font>
 void
 check_gc_signals_unblocked_or_lose(sigset_t *sigset)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (gc_signals_blocked_p(sigset))
         lose("gc signals blocked\n");
 #endif
<font color="#0000FF">@@ -386,7 +386,7 @@ check_gc_signals_unblocked_or_lose(sigset_t *sigset)</font>
 void
 check_gc_signals_blocked_or_lose(sigset_t *sigset)
 {
<font color="#FF6600">-#if !defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (!gc_signals_blocked_p(sigset))
         lose("gc signals unblocked\n");
 #endif
<font color="#0000FF">@@ -395,7 +395,10 @@ check_gc_signals_blocked_or_lose(sigset_t *sigset)</font>
 void
 block_deferrable_signals(sigset_t *where, sigset_t *old)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("block deferrable");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     block_signals(&amp;deferrable_sigset, where, old);
 #endif
 }
<font color="#0000FF">@@ -403,7 +406,10 @@ block_deferrable_signals(sigset_t *where, sigset_t *old)</font>
 void
 block_blockable_signals(sigset_t *where, sigset_t *old)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("block blockable");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     block_signals(&amp;blockable_sigset, where, old);
 #endif
 }
<font color="#0000FF">@@ -411,7 +417,10 @@ block_blockable_signals(sigset_t *where, sigset_t *old)</font>
 void
 block_gc_signals(sigset_t *where, sigset_t *old)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("block gc");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     block_signals(&amp;gc_sigset, where, old);
 #endif
 }
<font color="#0000FF">@@ -419,7 +428,10 @@ block_gc_signals(sigset_t *where, sigset_t *old)</font>
 void
 unblock_deferrable_signals(sigset_t *where, sigset_t *old)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("unblock deferrable");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (interrupt_handler_pending_p())
         lose("unblock_deferrable_signals: losing proposition\n");
     check_gc_signals_unblocked_or_lose(where);
<font color="#0000FF">@@ -430,7 +442,10 @@ unblock_deferrable_signals(sigset_t *where, sigset_t *old)</font>
 void
 unblock_blockable_signals(sigset_t *where, sigset_t *old)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("unblock blockable");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     unblock_signals(&amp;blockable_sigset, where, old);
 #endif
 }
<font color="#0000FF">@@ -438,7 +453,10 @@ unblock_blockable_signals(sigset_t *where, sigset_t *old)</font>
 void
 unblock_gc_signals(sigset_t *where, sigset_t *old)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    odprintf("unblock gc");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     unblock_signals(&amp;gc_sigset, where, old);
 #endif
 }
<font color="#0000FF">@@ -446,7 +464,7 @@ unblock_gc_signals(sigset_t *where, sigset_t *old)</font>
 void
 unblock_signals_in_context_and_maybe_warn(os_context_t *context)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     sigset_t *sigset = os_context_sigmask_addr(context);
     if (all_signals_blocked_p(sigset, &amp;gc_sigset, "gc")) {
         corruption_warning_and_maybe_lose(
<font color="#0000FF">@@ -480,7 +498,7 @@ check_interrupts_enabled_or_lose(os_context_t *context)</font>
 void
 maybe_save_gc_mask_and_block_deferrables(sigset_t *sigset)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     struct thread *thread = arch_os_get_current_thread();
     struct interrupt_data *data = thread-&gt;interrupt_data;
     sigset_t oldset;
<font color="#0000FF">@@ -536,7 +554,7 @@ in_leaving_without_gcing_race_p(struct thread *thread)</font>
 void
 check_interrupt_context_or_lose(os_context_t *context)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     struct thread *thread = arch_os_get_current_thread();
     struct interrupt_data *data = thread-&gt;interrupt_data;
     int interrupt_deferred_p = (data-&gt;pending_handler != 0);
<font color="#0000FF">@@ -777,7 +795,7 @@ interrupt_internal_error(os_context_t *context, boolean continuable)</font>
     unblock_gc_signals(0, 0);
     context_sap = alloc_sap(context);
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     thread_sigmask(SIG_SETMASK, os_context_sigmask_addr(context), 0);
 #endif
 
<font color="#0000FF">@@ -849,6 +867,10 @@ interrupt_handle_pending(os_context_t *context)</font>
      * Note, that if gc_blocked_deferrables is false we may still have
      * to GC. In this case, we are coming out of a WITHOUT-GCING or a
      * pseudo atomic was interrupt be a deferrable first. */
<font color="#009900">+    #if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    /* Handle_trap may be called from safepoint */</font>
<font color="#009900">+    if (context)</font>
<font color="#009900">+    #endif</font>
     if (data-&gt;gc_blocked_deferrables) {
         if (data-&gt;pending_handler)
             lose("GC blocked deferrables but still got a pending handler.");
<font color="#0000FF">@@ -859,7 +881,7 @@ interrupt_handle_pending(os_context_t *context)</font>
          * the os_context for the signal we're currently in the
          * handler for. This should ensure that when we return from
          * the handler the blocked signals are unblocked. */
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
         sigcopyset(os_context_sigmask_addr(context), &amp;data-&gt;pending_mask);
 #endif
         data-&gt;gc_blocked_deferrables = 0;
<font color="#0000FF">@@ -939,7 +961,16 @@ interrupt_handle_pending(os_context_t *context)</font>
                  original_pending_handler, data-&gt;pending_handler);
     }
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+  #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+  if (SymbolValue(INTERRUPTS_ENABLED, thread) != NIL</font>
<font color="#009900">+      &amp;&amp; SymbolValue(INTERRUPT_PENDING, thread) != NIL) {</font>
<font color="#009900">+    void check_pending_interrupts();</font>
<font color="#009900">+    </font>
<font color="#009900">+    check_pending_interrupts();</font>
<font color="#009900">+  }</font>
<font color="#009900">+  #endif</font>
<font color="#009900">+#else</font>
     /* There may be no pending handler, because it was only a gc that
      * had to be executed or because Lisp is a bit too eager to call
      * DO-PENDING-INTERRUPT. */
<font color="#0000FF">@@ -974,7 +1005,7 @@ interrupt_handle_now(int signal, siginfo_t *info, os_context_t *context)</font>
 
     check_blockables_blocked_or_lose(0);
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     if (sigismember(&amp;deferrable_sigset,signal))
         check_interrupts_enabled_or_lose(context);
 #endif
<font color="#0000FF">@@ -1036,11 +1067,11 @@ interrupt_handle_now(int signal, siginfo_t *info, os_context_t *context)</font>
 
         FSHOW_SIGNAL((stderr,"/calling C-level handler\n"));
 
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
         /* Allow signals again. */
         thread_sigmask(SIG_SETMASK, os_context_sigmask_addr(context), 0);
<font color="#FF6600">-#endif</font>
         (*handler.c)(signal, info, context);
<font color="#009900">+#endif</font>
     }
 
     if (were_in_lisp)
<font color="#0000FF">@@ -1308,7 +1339,7 @@ extern void call_into_lisp_tramp(void);</font>
 void
 arrange_return_to_lisp_function(os_context_t *context, lispobj function)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     check_gc_signals_unblocked_or_lose
         (os_context_sigmask_addr(context));
 #endif
<font color="#0000FF">@@ -1822,17 +1853,21 @@ sigabrt_handler(int signal, siginfo_t *info, os_context_t *context)</font>
 void
 interrupt_init(void)
 {
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     int i;
     SHOW("entering interrupt_init()");
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
     see_if_sigaction_nodefer_works();
<font color="#009900">+#endif</font>
     sigemptyset(&amp;deferrable_sigset);
     sigemptyset(&amp;blockable_sigset);
     sigemptyset(&amp;gc_sigset);
     sigaddset_deferrable(&amp;deferrable_sigset);
     sigaddset_blockable(&amp;blockable_sigset);
     sigaddset_gc(&amp;gc_sigset);
<font color="#009900">+#endif</font>
 
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
     /* Set up high level handler information. */
     for (i = 0; i &lt; NSIG; i++) {
         interrupt_handlers[i].c =
<font color="#0000FF">@@ -1844,8 +1879,8 @@ interrupt_init(void)</font>
             (void (*)(int, siginfo_t*, os_context_t*))SIG_DFL;
     }
     undoably_install_low_level_interrupt_handler(SIGABRT, sigabrt_handler);
<font color="#FF6600">-    SHOW("returning from interrupt_init()");</font>
 #endif
<font color="#009900">+    SHOW("returning from interrupt_init()");</font>
 }
 
 #ifndef LISP_FEATURE_WIN32
<font color="#0000FF">@@ -1892,7 +1927,7 @@ unhandled_trap_error(os_context_t *context)</font>
     fake_foreign_function_call(context);
     unblock_gc_signals(0, 0);
     context_sap = alloc_sap(context);
<font color="#FF6600">-#ifndef LISP_FEATURE_WIN32</font>
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32) || defined(LISP_FEATURE_SB_THREAD)</font>
     thread_sigmask(SIG_SETMASK, os_context_sigmask_addr(context), 0);
 #endif
     funcall1(StaticSymbolFunction(UNHANDLED_TRAP_ERROR), context_sap);
<font color="#0000FF">@@ -1909,7 +1944,11 @@ handle_trap(os_context_t *context, int trap)</font>
     case trap_PendingInterrupt:
         FSHOW((stderr, "/&lt;trap pending interrupt&gt;\n"));
         arch_skip_instruction(context);
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        gc_safepoint();</font>
<font color="#009900">+#else</font>
         interrupt_handle_pending(context);
<font color="#009900">+#endif</font>
         break;
     case trap_Error:
     case trap_Cerror:
diff --git a/src/runtime/interrupt.h b/src/runtime/interrupt.h
index 05c6638..21997f3 100644
<font color="#FF6600">--- a/src/runtime/interrupt.h</font>
<font color="#009900">+++ b/src/runtime/interrupt.h</font>
<font color="#0000FF">@@ -12,8 +12,12 @@</font>
 #if !defined(_INCLUDE_INTERRUPT_H_)
 #define _INCLUDE_INTERRUPT_H_
 
<font color="#009900">+#include "sbcl.h"</font>
<font color="#009900">+#include "runtime.h"</font>
 #include &lt;signal.h&gt;
<font color="#009900">+#include &lt;sys/types.h&gt;</font>
 #include &lt;string.h&gt;
<font color="#009900">+#include "os.h"</font>
 
 /*
  * This is a workaround for some slightly silly Linux/GNU Libc
<font color="#0000FF">@@ -101,7 +105,18 @@ union interrupt_handler {</font>
 
 extern union interrupt_handler interrupt_handlers[NSIG];
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+struct win32_interrupt_data {</font>
<font color="#009900">+    int interrupts_count;</font>
<font color="#009900">+    lispobj interrupts[MAX_INTERRUPTS];</font>
<font color="#009900">+    pthread_mutex_t lock;</font>
<font color="#009900">+};</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 struct interrupt_data {
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    struct win32_interrupt_data win32_data;</font>
<font color="#009900">+#endif</font>
     /* signal information for pending signal.  pending_signal=0 when there
      * is no pending signal. */
     void (*pending_handler) (int, siginfo_t*, os_context_t*) ;
diff --git a/src/runtime/monitor.c b/src/runtime/monitor.c
index 45a9b00..94ac1f8 100644
<font color="#FF6600">--- a/src/runtime/monitor.c</font>
<font color="#009900">+++ b/src/runtime/monitor.c</font>
<font color="#0000FF">@@ -19,7 +19,7 @@</font>
 #ifndef LISP_FEATURE_WIN32
 #include &lt;sys/resource.h&gt;
 #endif
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
 #include &lt;unistd.h&gt;
 
 #include "runtime.h"
diff --git a/src/runtime/parse.c b/src/runtime/parse.c
index beedc29..a1aaa2e 100644
<font color="#FF6600">--- a/src/runtime/parse.c</font>
<font color="#009900">+++ b/src/runtime/parse.c</font>
<font color="#0000FF">@@ -14,7 +14,6 @@</font>
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;ctype.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 
 #include "sbcl.h"
 #include "runtime.h"
diff --git a/src/runtime/pthread-futex.c b/src/runtime/pthread-futex.c
index cddcda9..167641a 100644
<font color="#FF6600">--- a/src/runtime/pthread-futex.c</font>
<font color="#009900">+++ b/src/runtime/pthread-futex.c</font>
<font color="#0000FF">@@ -16,7 +16,7 @@</font>
 #if defined(LISP_FEATURE_SB_THREAD) &amp;&amp; defined(LISP_FEATURE_SB_PTHREAD_FUTEX)
 
 #include &lt;errno.h&gt;
<font color="#FF6600">-#include &lt;pthread.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
 #include &lt;stdlib.h&gt;
 
 #include "runtime.h"
<font color="#0000FF">@@ -26,6 +26,10 @@</font>
 
 #define FUTEX_WAIT_NSEC (10000000) /* 10 msec */
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#define EWOULDBLOCK 3</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 #if 1
 # define futex_assert(ex)                                              \
 do {                                                                   \
<font color="#0000FF">@@ -230,6 +234,10 @@ futex_wait(int *lock_word, int oldval, long sec, unsigned long usec)</font>
     sigset_t oldset;
     struct timeval tv, *timeout;
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    gc_enter_safe_region();</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 again:
     if (sec &lt; 0)
         timeout = NULL;
<font color="#0000FF">@@ -260,8 +268,10 @@ again:</font>
 
     /* It's not possible to unwind frames across pthread_cond_wait(3). */
     for (;;) {
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32)</font>
         int i;
         sigset_t pendset;
<font color="#009900">+#endif</font>
         struct timespec abstime;
 
         ret = futex_relative_to_abs(&amp;abstime, FUTEX_WAIT_NSEC);
<font color="#0000FF">@@ -274,9 +284,17 @@ again:</font>
         if (result != ETIMEDOUT || futex_istimeout(timeout))
             break;
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+        if (*(volatile int *)lock_word != oldval) {</font>
<font color="#009900">+            result = EINTR;</font>
<font color="#009900">+            goto done;</font>
<font color="#009900">+        }</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
         /* futex system call of Linux returns with EINTR errno when
          * it's interrupted by signals.  Check pending signals here to
          * emulate this behaviour. */
<font color="#009900">+#if !defined(LISP_FEATURE_WIN32)</font>
         sigpending(&amp;pendset);
         for (i = 1; i &lt; NSIG; i++) {
             if (sigismember(&amp;pendset, i) &amp;&amp; sigismember(&amp;newset, i)) {
<font color="#0000FF">@@ -284,6 +302,7 @@ again:</font>
                 goto done;
             }
         }
<font color="#009900">+#endif</font>
     }
 done:
     ; /* Null statement is required between label and pthread_cleanup_pop. */
<font color="#0000FF">@@ -296,6 +315,10 @@ done:</font>
         sched_yield();
         goto again;
     }
<font color="#009900">+	</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+	gc_leave_region();</font>
<font color="#009900">+#endif</font>
 
     if (result == ETIMEDOUT)
         return 1;
diff --git a/src/runtime/pthreads_win32.c b/src/runtime/pthreads_win32.c
new file mode 100755
index 0000000..7ade34f
<font color="#FF6600">--- /dev/null</font>
<font color="#009900">+++ b/src/runtime/pthreads_win32.c</font>
<font color="#0000FF">@@ -0,0 +1,538 @@</font>
<font color="#009900">+#include "sbcl.h"</font>
<font color="#009900">+</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+#include "pthreads_win32.h"</font>
<font color="#009900">+#include &lt;stdlib.h&gt;</font>
<font color="#009900">+#include &lt;stdio.h&gt;</font>
<font color="#009900">+#include &lt;time.h&gt;</font>
<font color="#009900">+#include &lt;sys/time.h&gt;</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_attr_init(pthread_attr_t *attr)</font>
<font color="#009900">+{</font>
<font color="#009900">+  attr-&gt;stack_size = 0;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_attr_destroy(pthread_attr_t *attr)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize)</font>
<font color="#009900">+{</font>
<font color="#009900">+  fprintf(stderr, "pthread_attr_setstack called\n");</font>
<font color="#009900">+  ExitProcess(1);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)</font>
<font color="#009900">+{</font>
<font color="#009900">+  attr-&gt;stack_size = stacksize;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+DWORD thread_self_tls_index;</font>
<font color="#009900">+</font>
<font color="#009900">+typedef unsigned char boolean;</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_suspend(pthread_t thread)</font>
<font color="#009900">+{</font>
<font color="#009900">+  CONTEXT context;</font>
<font color="#009900">+  SuspendThread(thread-&gt;handle);</font>
<font color="#009900">+  context.ContextFlags = CONTEXT_FULL;</font>
<font color="#009900">+  GetThreadContext(thread-&gt;handle, &amp;context);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_np_get_thread_context(pthread_t thread, CONTEXT* context)</font>
<font color="#009900">+{</font>
<font color="#009900">+  context-&gt;ContextFlags = CONTEXT_FULL;</font>
<font color="#009900">+  return GetThreadContext(thread-&gt;handle, context) != 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_resume(pthread_t thread)</font>
<font color="#009900">+{</font>
<font color="#009900">+  ResumeThread(thread-&gt;handle);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_request_interruption(pthread_t thread)</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (thread-&gt;waiting_cond) {</font>
<font color="#009900">+    pthread_cond_broadcast(thread-&gt;waiting_cond);</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+pthread_t pthread_self()</font>
<font color="#009900">+{</font>
<font color="#009900">+  return (pthread_t)TlsGetValue(thread_self_tls_index);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+const char * state_to_str(pthread_thread_state state)</font>
<font color="#009900">+{</font>
<font color="#009900">+  switch (state) {</font>
<font color="#009900">+    case pthread_state_running: return "running";</font>
<font color="#009900">+    case pthread_state_finished: return "finished";</font>
<font color="#009900">+    case pthread_state_joined: return "joined";</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+DWORD WINAPI Thread_Function(LPVOID param)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_t self = (pthread_t)param;</font>
<font color="#009900">+  void* arg = self-&gt;arg;</font>
<font color="#009900">+  void* retval = NULL;</font>
<font color="#009900">+  pthread_fn fn = self-&gt;start_routine;</font>
<font color="#009900">+</font>
<font color="#009900">+  TlsSetValue(thread_self_tls_index, self);</font>
<font color="#009900">+  self-&gt;retval = fn(arg);</font>
<font color="#009900">+  pthread_mutex_lock(&amp;self-&gt;lock);</font>
<font color="#009900">+  self-&gt;state = pthread_state_finished;</font>
<font color="#009900">+  pthread_cond_broadcast(&amp;self-&gt;cond);</font>
<font color="#009900">+  while (!self-&gt;detached &amp;&amp; self-&gt;state != pthread_state_joined) {</font>
<font color="#009900">+    pthread_cond_wait(&amp;self-&gt;cond, &amp;self-&gt;lock);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;self-&gt;lock);</font>
<font color="#009900">+</font>
<font color="#009900">+  pthread_mutex_destroy(&amp;self-&gt;lock);</font>
<font color="#009900">+  pthread_cond_destroy(&amp;self-&gt;cond);</font>
<font color="#009900">+  CloseHandle(self-&gt;handle);</font>
<font color="#009900">+</font>
<font color="#009900">+  free(self);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_t pth = (pthread_t)malloc(sizeof(pthread_thread));</font>
<font color="#009900">+  pthread_t self = pthread_self();</font>
<font color="#009900">+  int i;</font>
<font color="#009900">+  HANDLE createdThread = CreateThread(NULL, attr ? attr-&gt;stack_size : 0,</font>
<font color="#009900">+                                      Thread_Function, pth, CREATE_SUSPENDED, NULL);</font>
<font color="#009900">+  if (!createdThread)</font>
<font color="#009900">+    return 1;</font>
<font color="#009900">+  pth-&gt;start_routine = start_routine;</font>
<font color="#009900">+  pth-&gt;arg = arg;</font>
<font color="#009900">+  pth-&gt;handle = createdThread;</font>
<font color="#009900">+  pth-&gt;waiting_cond = NULL;</font>
<font color="#009900">+</font>
<font color="#009900">+  if (self) {</font>
<font color="#009900">+    pth-&gt;blocked_signal_set = self-&gt;blocked_signal_set;</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    sigemptyset(&amp;pth-&gt;blocked_signal_set);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  for (i = 1; i &lt; NSIG; ++i)</font>
<font color="#009900">+    pth-&gt;signal_is_pending[i] = 0;</font>
<font color="#009900">+  pth-&gt;state = pthread_state_running;</font>
<font color="#009900">+  pthread_mutex_init(&amp;pth-&gt;lock, NULL);</font>
<font color="#009900">+  pthread_cond_init(&amp;pth-&gt;cond, NULL);</font>
<font color="#009900">+  pth-&gt;detached = 0;</font>
<font color="#009900">+  ResumeThread(createdThread);</font>
<font color="#009900">+  if (thread)</font>
<font color="#009900">+    *thread = createdThread;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_equal(pthread_t thread1, pthread_t thread2)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return thread1 == thread2;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_detach(pthread_t thread)</font>
<font color="#009900">+{</font>
<font color="#009900">+  int retval = 0;</font>
<font color="#009900">+  pthread_mutex_lock(&amp;thread-&gt;lock);</font>
<font color="#009900">+  thread-&gt;detached = 1;</font>
<font color="#009900">+  pthread_cond_broadcast(&amp;thread-&gt;cond);</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;thread-&gt;lock);</font>
<font color="#009900">+  return retval;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_join(pthread_t thread, void **retval)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_mutex_lock(&amp;thread-&gt;lock);</font>
<font color="#009900">+  while (thread-&gt;state != pthread_state_finished) {</font>
<font color="#009900">+    pthread_cond_wait(&amp;thread-&gt;cond, &amp;thread-&gt;lock);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  thread-&gt;state = pthread_state_joined;</font>
<font color="#009900">+  pthread_cond_broadcast(&amp;thread-&gt;cond);</font>
<font color="#009900">+  if (retval)</font>
<font color="#009900">+    *retval = thread-&gt;retval;</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;thread-&gt;lock);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))</font>
<font color="#009900">+{</font>
<font color="#009900">+  DWORD index;</font>
<font color="#009900">+  if (destructor) {</font>
<font color="#009900">+    fprintf(stderr, "destructor is specified for pthread_key_create\n");</font>
<font color="#009900">+    ExitProcess(1);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  index = TlsAlloc();</font>
<font color="#009900">+  if (index == TLS_OUT_OF_INDEXES)</font>
<font color="#009900">+    return 1;</font>
<font color="#009900">+  *key = index;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void *pthread_getspecific(pthread_key_t key)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return TlsGetValue(key);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_setspecific(pthread_key_t key, const void *value)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return TlsSetValue(key, (LPVOID)value) != FALSE;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_t self = pthread_self();</font>
<font color="#009900">+  if (oldset)</font>
<font color="#009900">+    *oldset = self-&gt;blocked_signal_set;</font>
<font color="#009900">+  if (set) {</font>
<font color="#009900">+    const char * action;</font>
<font color="#009900">+</font>
<font color="#009900">+    switch (how) {</font>
<font color="#009900">+      case SIG_BLOCK:</font>
<font color="#009900">+        action = "blocking";</font>
<font color="#009900">+        self-&gt;blocked_signal_set |= *set;</font>
<font color="#009900">+        break;</font>
<font color="#009900">+      case SIG_UNBLOCK:</font>
<font color="#009900">+        action = "unblocking";</font>
<font color="#009900">+        self-&gt;blocked_signal_set &amp;= ~(*set);</font>
<font color="#009900">+        break;</font>
<font color="#009900">+      case SIG_SETMASK:</font>
<font color="#009900">+        action = "setting";</font>
<font color="#009900">+        self-&gt;blocked_signal_set = *set;</font>
<font color="#009900">+        break;</font>
<font color="#009900">+    }</font>
<font color="#009900">+    if (0)</font>
<font color="#009900">+    {</font>
<font color="#009900">+      char buf[100];</font>
<font color="#009900">+      sprintf(buf, "[0x%p] set signals mask to 0x%x by %s of 0x%x", self, self-&gt;blocked_signal_set, action, *set);</font>
<font color="#009900">+      OutputDebugString(buf);</font>
<font color="#009900">+    }</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (set)</font>
<font color="#009900">+  {</font>
<font color="#009900">+    int i;</font>
<font color="#009900">+    for (i = 1; i &lt; NSIG; ++i) {</font>
<font color="#009900">+      if (!sigismember(&amp;self-&gt;blocked_signal_set, i)) {</font>
<font color="#009900">+        unsigned int is_pending = InterlockedExchange(&amp;self-&gt;signal_is_pending[i], 0);</font>
<font color="#009900">+        if (is_pending) {</font>
<font color="#009900">+          pthread_np_pending_signal_handler(i);</font>
<font color="#009900">+        }</font>
<font color="#009900">+      }</font>
<font color="#009900">+    }</font>
<font color="#009900">+  }</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+pthread_mutex_t mutex_init_lock;</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * attr)</font>
<font color="#009900">+{</font>
<font color="#009900">+  *mutex = (CRITICAL_SECTION*)malloc(sizeof(CRITICAL_SECTION));</font>
<font color="#009900">+  InitializeCriticalSection(*mutex);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutexattr_init(pthread_mutexattr_t* attr)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+int pthread_mutexattr_destroy(pthread_mutexattr_t* attr)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutexattr_settype(pthread_mutexattr_t* attr,int mutex_type)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutex_destroy(pthread_mutex_t *mutex)</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (*mutex != PTHREAD_MUTEX_INITIALIZER)</font>
<font color="#009900">+    DeleteCriticalSection(*mutex);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_add_pending_signal(pthread_t thread, int signum)</font>
<font color="#009900">+{</font>
<font color="#009900">+  const char * s = thread-&gt;signal_is_pending[signum] ? "pending" : "not pending";</font>
<font color="#009900">+  thread-&gt;signal_is_pending[signum] = 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_remove_pending_signal(pthread_t thread, int signum)</font>
<font color="#009900">+{</font>
<font color="#009900">+  const char * s = thread-&gt;signal_is_pending[signum] ? "pending" : "not pending";</font>
<font color="#009900">+  thread-&gt;signal_is_pending[signum] = 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutex_lock(pthread_mutex_t *mutex)</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (*mutex == PTHREAD_MUTEX_INITIALIZER) {</font>
<font color="#009900">+    pthread_mutex_lock(&amp;mutex_init_lock);</font>
<font color="#009900">+    if (*mutex == PTHREAD_MUTEX_INITIALIZER) {</font>
<font color="#009900">+      *mutex = (CRITICAL_SECTION*)malloc(sizeof(CRITICAL_SECTION));</font>
<font color="#009900">+      pthread_mutex_init(mutex, NULL);</font>
<font color="#009900">+    }</font>
<font color="#009900">+    pthread_mutex_unlock(&amp;mutex_init_lock);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  EnterCriticalSection(*mutex);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutex_trylock(pthread_mutex_t *mutex)</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (*mutex == PTHREAD_MUTEX_INITIALIZER) {</font>
<font color="#009900">+    pthread_mutex_lock(&amp;mutex_init_lock);</font>
<font color="#009900">+    if (*mutex == PTHREAD_MUTEX_INITIALIZER) {</font>
<font color="#009900">+      *mutex = (CRITICAL_SECTION*)malloc(sizeof(CRITICAL_SECTION));</font>
<font color="#009900">+      pthread_mutex_init(mutex, NULL);</font>
<font color="#009900">+    }</font>
<font color="#009900">+    pthread_mutex_unlock(&amp;mutex_init_lock);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (TryEnterCriticalSection(*mutex))</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  else</font>
<font color="#009900">+    return EBUSY;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_mutex_unlock(pthread_mutex_t *mutex)</font>
<font color="#009900">+{</font>
<font color="#009900">+  LeaveCriticalSection(*mutex);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+static HANDLE cv_default_event_get_fn()</font>
<font color="#009900">+{</font>
<font color="#009900">+  return CreateEvent(NULL, FALSE, FALSE, NULL);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+static void cv_default_event_return_fn(HANDLE event)</font>
<font color="#009900">+{</font>
<font color="#009900">+  CloseHandle(event);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_cond_init(pthread_cond_t * cv, const pthread_condattr_t * attr)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_mutex_init(&amp;cv-&gt;wakeup_lock, NULL);</font>
<font color="#009900">+  cv-&gt;first_wakeup = NULL;</font>
<font color="#009900">+  cv-&gt;last_wakeup = NULL;</font>
<font color="#009900">+  cv-&gt;alertable = 0;</font>
<font color="#009900">+  cv-&gt;get_fn = cv_default_event_get_fn;</font>
<font color="#009900">+  cv-&gt;return_fn = cv_default_event_return_fn;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_cond_destroy(pthread_cond_t *cv)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_mutex_destroy(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_cond_broadcast(pthread_cond_t *cv)</font>
<font color="#009900">+{</font>
<font color="#009900">+  int count = 0;</font>
<font color="#009900">+  pthread_mutex_lock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  while (cv-&gt;first_wakeup)</font>
<font color="#009900">+  {</font>
<font color="#009900">+    struct thread_wakeup * w = cv-&gt;first_wakeup;</font>
<font color="#009900">+    HANDLE waitevent = w-&gt;event;</font>
<font color="#009900">+    cv-&gt;first_wakeup = w-&gt;next;</font>
<font color="#009900">+    SetEvent(waitevent);</font>
<font color="#009900">+    ++count;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  cv-&gt;last_wakeup = NULL;</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_cond_signal(pthread_cond_t *cv)</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread_wakeup * w;</font>
<font color="#009900">+  pthread_mutex_lock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  w = cv-&gt;first_wakeup;</font>
<font color="#009900">+  if (w) {</font>
<font color="#009900">+    HANDLE waitevent = w-&gt;event;</font>
<font color="#009900">+    cv-&gt;first_wakeup = w-&gt;next;</font>
<font color="#009900">+    if (!cv-&gt;first_wakeup)</font>
<font color="#009900">+      cv-&gt;last_wakeup = NULL;</font>
<font color="#009900">+    SetEvent(waitevent);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void cv_wakeup_add(struct pthread_cond_t* cv, struct thread_wakeup* w)</font>
<font color="#009900">+{</font>
<font color="#009900">+  w-&gt;event = cv-&gt;get_fn();</font>
<font color="#009900">+  w-&gt;next = NULL;</font>
<font color="#009900">+  pthread_mutex_lock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  if (cv-&gt;last_wakeup == w) {</font>
<font color="#009900">+    fprintf(stderr, "cv-&gt;last_wakeup == w\n");</font>
<font color="#009900">+    ExitProcess(0);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (cv-&gt;last_wakeup != NULL)</font>
<font color="#009900">+  {</font>
<font color="#009900">+    cv-&gt;last_wakeup-&gt;next = w;</font>
<font color="#009900">+    cv-&gt;last_wakeup = w;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  else</font>
<font color="#009900">+  {</font>
<font color="#009900">+    cv-&gt;first_wakeup = w;</font>
<font color="#009900">+    cv-&gt;last_wakeup = w;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void cv_wakeup_remove(struct pthread_cond_t* cv, struct thread_wakeup* w)</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_mutex_lock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+  {</font>
<font color="#009900">+    if (cv-&gt;first_wakeup == w) {</font>
<font color="#009900">+      cv-&gt;first_wakeup = w-&gt;next;</font>
<font color="#009900">+      if (cv-&gt;last_wakeup == w)</font>
<font color="#009900">+        cv-&gt;last_wakeup = NULL;</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      struct thread_wakeup * prev = cv-&gt;first_wakeup;</font>
<font color="#009900">+      while (prev &amp;&amp; prev-&gt;next != w)</font>
<font color="#009900">+        prev = prev-&gt;next;</font>
<font color="#009900">+      if (!prev) {</font>
<font color="#009900">+        pthread_mutex_unlock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+        return;</font>
<font color="#009900">+      }</font>
<font color="#009900">+      prev-&gt;next = w-&gt;next;</font>
<font color="#009900">+      if (cv-&gt;last_wakeup == w)</font>
<font color="#009900">+        cv-&gt;last_wakeup = prev;</font>
<font color="#009900">+    }</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;cv-&gt;wakeup_lock);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_cond_wait(pthread_cond_t * cv, pthread_mutex_t * cs)</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread_wakeup w;</font>
<font color="#009900">+  cv_wakeup_add(cv, &amp;w);</font>
<font color="#009900">+  if (cv-&gt;last_wakeup-&gt;next == cv-&gt;last_wakeup) {</font>
<font color="#009900">+    fprintf(stderr, "cv-&gt;last_wakeup-&gt;next == cv-&gt;last_wakeup\n");</font>
<font color="#009900">+    ExitProcess(0);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (cv-&gt;last_wakeup-&gt;next != NULL) {</font>
<font color="#009900">+    fprintf(stderr, "cv-&gt;last_wakeup-&gt;next != NULL\n");</font>
<font color="#009900">+    ExitProcess(0);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_self()-&gt;waiting_cond = cv;</font>
<font color="#009900">+  pthread_mutex_unlock(cs);</font>
<font color="#009900">+  if (cv-&gt;alertable) {</font>
<font color="#009900">+    while (WaitForSingleObjectEx(w.event, INFINITE, TRUE) == WAIT_IO_COMPLETION);</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    WaitForSingleObject(w.event, INFINITE);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_self()-&gt;waiting_cond = NULL;</font>
<font color="#009900">+  cv-&gt;return_fn(w.event);</font>
<font color="#009900">+  pthread_mutex_lock(cs);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_cond_timedwait(pthread_cond_t * cv, pthread_mutex_t * cs, const struct timespec * abstime)</font>
<font color="#009900">+{</font>
<font color="#009900">+  DWORD rv;</font>
<font color="#009900">+  struct thread_wakeup w;</font>
<font color="#009900">+  cv_wakeup_add(cv, &amp;w);</font>
<font color="#009900">+  if (cv-&gt;last_wakeup-&gt;next == cv-&gt;last_wakeup) {</font>
<font color="#009900">+    fprintf(stderr, "cv-&gt;last_wakeup-&gt;next == cv-&gt;last_wakeup\n");</font>
<font color="#009900">+    ExitProcess(0);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_self()-&gt;waiting_cond = cv;</font>
<font color="#009900">+  pthread_mutex_unlock(cs);</font>
<font color="#009900">+  {</font>
<font color="#009900">+    struct timeval cur_tm;</font>
<font color="#009900">+    long sec, msec;</font>
<font color="#009900">+    gettimeofday(&amp;cur_tm, NULL);</font>
<font color="#009900">+    sec = abstime-&gt;tv_sec - cur_tm.tv_sec;</font>
<font color="#009900">+    msec = sec * 1000 + abstime-&gt;tv_nsec / 1000000 - cur_tm.tv_usec / 1000;</font>
<font color="#009900">+    if (msec &lt; 0)</font>
<font color="#009900">+      msec = 0;</font>
<font color="#009900">+    if (cv-&gt;alertable) {</font>
<font color="#009900">+      while ((rv = WaitForSingleObjectEx(w.event, msec, TRUE)) == WAIT_IO_COMPLETION);</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      rv = WaitForSingleObject(w.event, msec);</font>
<font color="#009900">+    }</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_self()-&gt;waiting_cond = NULL;</font>
<font color="#009900">+  if (rv == WAIT_TIMEOUT)</font>
<font color="#009900">+    cv_wakeup_remove(cv, &amp;w);</font>
<font color="#009900">+  cv-&gt;return_fn(w.event);</font>
<font color="#009900">+  pthread_mutex_lock(cs);</font>
<font color="#009900">+  if (rv == WAIT_TIMEOUT)</font>
<font color="#009900">+    return ETIMEDOUT;</font>
<font color="#009900">+  else</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int sched_yield()</font>
<font color="#009900">+{</font>
<font color="#009900">+  SwitchToThread();</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_lock_structures()</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_mutex_lock(&amp;mutex_init_lock);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_unlock_structures()</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;mutex_init_lock);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthreads_win32_init()</font>
<font color="#009900">+{</font>
<font color="#009900">+  pthread_t pth = (pthread_t)malloc(sizeof(pthread_thread));</font>
<font color="#009900">+  thread_self_tls_index = TlsAlloc();</font>
<font color="#009900">+  pth-&gt;start_routine = NULL;</font>
<font color="#009900">+  pth-&gt;arg = NULL;</font>
<font color="#009900">+  pth-&gt;waiting_cond = NULL;</font>
<font color="#009900">+  sigemptyset(&amp;pth-&gt;blocked_signal_set);</font>
<font color="#009900">+  {</font>
<font color="#009900">+    int i;</font>
<font color="#009900">+    for (i = 1; i &lt; NSIG; ++i)</font>
<font color="#009900">+      pth-&gt;signal_is_pending[i] = 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  pthread_mutex_init(&amp;mutex_init_lock, NULL);</font>
<font color="#009900">+  DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &amp;pth-&gt;handle, 0, TRUE, DUPLICATE_SAME_ACCESS);</font>
<font color="#009900">+  TlsSetValue(thread_self_tls_index, pth);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int sigemptyset(sigset_t *set)</font>
<font color="#009900">+{</font>
<font color="#009900">+  *set = 0;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int sigfillset(sigset_t *set)</font>
<font color="#009900">+{</font>
<font color="#009900">+  *set = 0xfffffffful;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int sigaddset(sigset_t *set, int signum)</font>
<font color="#009900">+{</font>
<font color="#009900">+  *set |= 1 &lt;&lt; signum;</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int sigdelset(sigset_t *set, int signum)</font>
<font color="#009900">+{</font>
<font color="#009900">+  *set &amp;= ~(1 &lt;&lt; signum);</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int sigismember(const sigset_t *set, int signum)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return (*set &amp; (1 &lt;&lt; signum)) != 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+#endif</font>
diff --git a/src/runtime/pthreads_win32.h b/src/runtime/pthreads_win32.h
new file mode 100755
index 0000000..52d64a8
<font color="#FF6600">--- /dev/null</font>
<font color="#009900">+++ b/src/runtime/pthreads_win32.h</font>
<font color="#0000FF">@@ -0,0 +1,187 @@</font>
<font color="#009900">+#ifndef WIN32_PTHREAD_INCLUDED</font>
<font color="#009900">+#define WIN32_PTHREAD_INCLUDED</font>
<font color="#009900">+</font>
<font color="#009900">+#include &lt;time.h&gt;</font>
<font color="#009900">+#include &lt;errno.h&gt;</font>
<font color="#009900">+#include &lt;sys/types.h&gt;</font>
<font color="#009900">+</font>
<font color="#009900">+#define WIN32_LEAN_AND_MEAN</font>
<font color="#009900">+#include &lt;windows.h&gt;</font>
<font color="#009900">+</font>
<font color="#009900">+/* 0 - Misc */</font>
<font color="#009900">+</font>
<font color="#009900">+</font>
<font color="#009900">+#define SIG_IGN ((void (*)(int, siginfo_t, void*))-1)</font>
<font color="#009900">+#define SIG_DFL ((void (*)(int, siginfo_t, void*))-2)</font>
<font color="#009900">+</font>
<font color="#009900">+#define SIGHUP    1</font>
<font color="#009900">+#define SIGINT    2 /* Interactive attention */</font>
<font color="#009900">+#define SIGQUIT   3</font>
<font color="#009900">+#define SIGILL    4 /* Illegal instruction */</font>
<font color="#009900">+#define SIGPIPE   5</font>
<font color="#009900">+#define SIGALRM   6</font>
<font color="#009900">+#define SIGURG    7</font>
<font color="#009900">+#define SIGFPE    8 /* Floating point error */</font>
<font color="#009900">+#define SIGTSTP   9</font>
<font color="#009900">+#define SIGCHLD   10</font>
<font color="#009900">+#define SIGSEGV   11 /* Segmentation violation */</font>
<font color="#009900">+#define SIGIO     12</font>
<font color="#009900">+#define SIGXCPU   13</font>
<font color="#009900">+#define SIGXFSZ   14</font>
<font color="#009900">+#define SIGTERM   15 /* Termination request */</font>
<font color="#009900">+#define SIGVTALRM 16</font>
<font color="#009900">+#define SIGPROF   17</font>
<font color="#009900">+#define SIGWINCH  18</font>
<font color="#009900">+#define SIGBREAK  21 /* Control-break */</font>
<font color="#009900">+#define SIGABRT   22 /* Abnormal termination (abort) */</font>
<font color="#009900">+</font>
<font color="#009900">+#define SIGRTMIN  23</font>
<font color="#009900">+</font>
<font color="#009900">+#define SIG_DEFER SIGHUP</font>
<font color="#009900">+</font>
<font color="#009900">+#define NSIG 31     /* maximum signal number + 1 */</font>
<font color="#009900">+</font>
<font color="#009900">+void pthreads_win32_init();</font>
<font color="#009900">+</font>
<font color="#009900">+/* 1 - Thread */</font>
<font color="#009900">+</font>
<font color="#009900">+typedef struct pthread_thread* pthread_t;</font>
<font color="#009900">+</font>
<font color="#009900">+typedef struct pthread_attr_t {</font>
<font color="#009900">+  unsigned int stack_size;</font>
<font color="#009900">+} pthread_attr_t;</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_attr_init(pthread_attr_t *attr);</font>
<font color="#009900">+int pthread_attr_destroy(pthread_attr_t *attr);</font>
<font color="#009900">+int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</font>
<font color="#009900">+int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</font>
<font color="#009900">+</font>
<font color="#009900">+typedef void (*pthread_cleanup_fn)(void* arg);</font>
<font color="#009900">+</font>
<font color="#009900">+#define pthread_cleanup_push(fn, arg) { pthread_cleanup_fn __pthread_fn = fn; void *__pthread_arg = arg;</font>
<font color="#009900">+#define pthread_cleanup_pop(execute) if (execute) __pthread_fn(__pthread_arg); }</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</font>
<font color="#009900">+int pthread_equal(pthread_t thread1, pthread_t thread2);</font>
<font color="#009900">+int pthread_detach(pthread_t thread);</font>
<font color="#009900">+int pthread_join(pthread_t thread, void **retval);</font>
<font color="#009900">+pthread_t pthread_self(void);</font>
<font color="#009900">+</font>
<font color="#009900">+typedef DWORD pthread_key_t;</font>
<font color="#009900">+int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));</font>
<font color="#009900">+void *pthread_getspecific(pthread_key_t key);</font>
<font color="#009900">+int pthread_setspecific(pthread_key_t key, const void *value);</font>
<font color="#009900">+</font>
<font color="#009900">+#define SIG_BLOCK 1</font>
<font color="#009900">+#define SIG_UNBLOCK 2</font>
<font color="#009900">+#define SIG_SETMASK 3</font>
<font color="#009900">+int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);</font>
<font color="#009900">+</font>
<font color="#009900">+/* 1a - Thread non-portable */</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_suspend(pthread_t thread);</font>
<font color="#009900">+void pthread_np_suspend_with_signal(pthread_t thread, int signum);</font>
<font color="#009900">+void pthread_np_resume(pthread_t thread);</font>
<font color="#009900">+void pthread_np_request_interruption(pthread_t thread);</font>
<font color="#009900">+</font>
<font color="#009900">+/* 2 - Mutex */</font>
<font color="#009900">+</font>
<font color="#009900">+typedef CRITICAL_SECTION* pthread_mutex_t;</font>
<font color="#009900">+typedef int pthread_mutexattr_t;</font>
<font color="#009900">+#define PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t)-1)</font>
<font color="#009900">+int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * attr);</font>
<font color="#009900">+int pthread_mutexattr_init(pthread_mutexattr_t*);</font>
<font color="#009900">+int pthread_mutexattr_destroy(pthread_mutexattr_t*);</font>
<font color="#009900">+int pthread_mutexattr_settype(pthread_mutexattr_t*, int);</font>
<font color="#009900">+#define PTHREAD_MUTEX_ERRORCHECK 0</font>
<font color="#009900">+int pthread_mutex_destroy(pthread_mutex_t *mutex);</font>
<font color="#009900">+int pthread_mutex_lock(pthread_mutex_t *mutex);</font>
<font color="#009900">+int pthread_mutex_trylock(pthread_mutex_t *mutex);</font>
<font color="#009900">+int pthread_mutex_unlock(pthread_mutex_t *mutex);</font>
<font color="#009900">+</font>
<font color="#009900">+/* 3 - Condition variable */</font>
<font color="#009900">+</font>
<font color="#009900">+typedef struct thread_wakeup {</font>
<font color="#009900">+  HANDLE event;</font>
<font color="#009900">+  struct thread_wakeup *next;</font>
<font color="#009900">+} thread_wakeup;</font>
<font color="#009900">+</font>
<font color="#009900">+typedef HANDLE (*cv_event_get_fn)();</font>
<font color="#009900">+typedef void (*cv_event_return_fn)(HANDLE event);</font>
<font color="#009900">+</font>
<font color="#009900">+typedef struct pthread_cond_t {</font>
<font color="#009900">+  pthread_mutex_t wakeup_lock;</font>
<font color="#009900">+  struct thread_wakeup *first_wakeup;</font>
<font color="#009900">+  struct thread_wakeup *last_wakeup;</font>
<font color="#009900">+  unsigned char alertable;</font>
<font color="#009900">+  cv_event_get_fn get_fn;</font>
<font color="#009900">+  cv_event_return_fn return_fn;</font>
<font color="#009900">+} pthread_cond_t;</font>
<font color="#009900">+</font>
<font color="#009900">+typedef struct pthread_condattr_t {</font>
<font color="#009900">+  unsigned char alertable;</font>
<font color="#009900">+  cv_event_get_fn get_fn;</font>
<font color="#009900">+  cv_event_return_fn return_fn;</font>
<font color="#009900">+} pthread_condattr_t;</font>
<font color="#009900">+</font>
<font color="#009900">+#ifndef _TIMESPEC_DEFINED</font>
<font color="#009900">+typedef struct timespec {</font>
<font color="#009900">+  time_t tv_sec;</font>
<font color="#009900">+  long tv_nsec;</font>
<font color="#009900">+} timespec;</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
<font color="#009900">+// not implemented: PTHREAD_COND_INITIALIZER</font>
<font color="#009900">+int pthread_cond_destroy(pthread_cond_t *cond);</font>
<font color="#009900">+int pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * attr);</font>
<font color="#009900">+int pthread_cond_broadcast(pthread_cond_t *cond);</font>
<font color="#009900">+int pthread_cond_signal(pthread_cond_t *cond);</font>
<font color="#009900">+int pthread_cond_timedwait(pthread_cond_t * cond, pthread_mutex_t * mutex, const struct timespec * abstime);</font>
<font color="#009900">+int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex);</font>
<font color="#009900">+</font>
<font color="#009900">+#define ETIMEDOUT 123 //Something</font>
<font color="#009900">+</font>
<font color="#009900">+int sched_yield();</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_lock_structures();</font>
<font color="#009900">+void pthread_unlock_structures();</font>
<font color="#009900">+</font>
<font color="#009900">+typedef void *(*pthread_fn)(void*);</font>
<font color="#009900">+</font>
<font color="#009900">+typedef enum {</font>
<font color="#009900">+  pthread_state_running,</font>
<font color="#009900">+  pthread_state_finished,</font>
<font color="#009900">+  pthread_state_joined</font>
<font color="#009900">+} pthread_thread_state;</font>
<font color="#009900">+</font>
<font color="#009900">+typedef struct pthread_thread {</font>
<font color="#009900">+  pthread_fn start_routine;</font>
<font color="#009900">+  void* arg;</font>
<font color="#009900">+  HANDLE handle;</font>
<font color="#009900">+  pthread_cond_t *waiting_cond;</font>
<font color="#009900">+  sigset_t blocked_signal_set;</font>
<font color="#009900">+  unsigned int signal_is_pending[NSIG];</font>
<font color="#009900">+  void * retval;</font>
<font color="#009900">+  </font>
<font color="#009900">+  pthread_mutex_t lock;</font>
<font color="#009900">+  pthread_cond_t cond;</font>
<font color="#009900">+  int detached;</font>
<font color="#009900">+  pthread_thread_state state;</font>
<font color="#009900">+} pthread_thread;</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_pending_signal_handler(int signum);</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_add_pending_signal(pthread_t thread, int signum);</font>
<font color="#009900">+void pthread_np_remove_pending_signal(pthread_t thread, int signum);</font>
<font color="#009900">+</font>
<font color="#009900">+int pthread_np_get_thread_context(pthread_t thread, CONTEXT* context);</font>
<font color="#009900">+</font>
<font color="#009900">+int sigemptyset(sigset_t *set);</font>
<font color="#009900">+int sigfillset(sigset_t *set);</font>
<font color="#009900">+int sigaddset(sigset_t *set, int signum);</font>
<font color="#009900">+int sigdelset(sigset_t *set, int signum);</font>
<font color="#009900">+int sigismember(const sigset_t *set, int signum);</font>
<font color="#009900">+</font>
<font color="#009900">+typedef int sig_atomic_t;</font>
<font color="#009900">+</font>
<font color="#009900">+#endif</font>
diff --git a/src/runtime/run-program.c b/src/runtime/run-program.c
index d1d98e6..199bde8 100644
<font color="#FF6600">--- a/src/runtime/run-program.c</font>
<font color="#009900">+++ b/src/runtime/run-program.c</font>
<font color="#0000FF">@@ -20,7 +20,7 @@</font>
 #include &lt;stdlib.h&gt;
 #include &lt;sys/file.h&gt;
 #include &lt;sys/types.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
 #include &lt;sys/stat.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;sys/ioctl.h&gt;
diff --git a/src/runtime/runtime.c b/src/runtime/runtime.c
index 0f1f0ff..7302cb1 100644
<font color="#FF6600">--- a/src/runtime/runtime.c</font>
<font color="#009900">+++ b/src/runtime/runtime.c</font>
<font color="#0000FF">@@ -29,7 +29,7 @@</font>
 #include &lt;sys/file.h&gt;
 #include &lt;sys/param.h&gt;
 #include &lt;sys/stat.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
 #ifndef LISP_FEATURE_WIN32
 #include &lt;sched.h&gt;
 #endif
<font color="#0000FF">@@ -41,7 +41,9 @@</font>
 #include &lt;time.h&gt;
 #endif
 
<font color="#009900">+#if !(defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD))</font>
 #include "signal.h"
<font color="#009900">+#endif</font>
 
 #include "runtime.h"
 #include "vars.h"
<font color="#0000FF">@@ -289,6 +291,10 @@ char *core_string;</font>
 struct runtime_options *runtime_options;
 
 char *saved_runtime_path = NULL;
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+void pthreads_win32_init();</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 
 int
 main(int argc, char *argv[], char *envp[])
<font color="#0000FF">@@ -313,6 +319,11 @@ main(int argc, char *argv[], char *envp[])</font>
     lispobj initial_function;
     const char *sbcl_home = getenv("SBCL_HOME");
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    os_preinit();</font>
<font color="#009900">+    pthreads_win32_init();</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
     interrupt_init();
     block_blockable_signals(0, 0);
 
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index de83bc8..d1ee399 100644
<font color="#FF6600">--- a/src/runtime/runtime.h</font>
<font color="#009900">+++ b/src/runtime/runtime.h</font>
<font color="#0000FF">@@ -15,6 +15,13 @@</font>
 #ifndef _SBCL_RUNTIME_H_
 #define _SBCL_RUNTIME_H_
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+#include "pthreads_win32.h"</font>
<font color="#009900">+#else</font>
<font color="#009900">+#include &lt;signal.h&gt;</font>
<font color="#009900">+#include &lt;pthread.h&gt;</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 #if defined(LISP_FEATURE_SB_THREAD)
 #define thread_self() pthread_self()
 #define thread_kill pthread_kill
<font color="#0000FF">@@ -29,6 +36,12 @@</font>
 #define thread_mutex_unlock(l) 0
 #endif
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+void os_preinit();</font>
<font color="#009900">+void map_gc_page();</font>
<font color="#009900">+void unmap_gc_page();</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 /* Block blockable interrupts for each SHOW, if not 0. */
 #define QSHOW_SIGNAL_SAFE 1
 /* Enable extra-verbose low-level debugging output for signals? (You
<font color="#0000FF">@@ -51,7 +64,6 @@</font>
 
 #if QSHOW_SIGNAL_SAFE == 1 &amp;&amp; !defined(LISP_FEATURE_WIN32)
 
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 extern sigset_t blockable_sigset;
 
 #define QSHOW_BLOCK                                             \
<font color="#0000FF">@@ -109,8 +121,25 @@ typedef unsigned long pointer_sized_uint_t ;</font>
 
 #include &lt;sys/types.h&gt;
 
<font color="#009900">+</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+</font>
<font color="#009900">+void odprintf_(const char * fmt, ...);</font>
<font color="#009900">+#if defined(LISP_FEATURE_DEBUG_WIN32)</font>
<font color="#009900">+#define odprintf odprintf_</font>
<font color="#009900">+#else</font>
<font color="#009900">+#define odprintf(...)</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 #if defined(LISP_FEATURE_SB_THREAD)
<font color="#FF6600">-#include &lt;pthread.h&gt;</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+void gc_safepoint();</font>
<font color="#009900">+void gc_enter_safe_region();</font>
<font color="#009900">+void gc_enter_unsafe_region();</font>
<font color="#009900">+void gc_leave_region();</font>
<font color="#009900">+#endif</font>
 typedef pthread_t os_thread_t;
 #else
 typedef pid_t os_thread_t;
diff --git a/src/runtime/save.c b/src/runtime/save.c
index b3addc9..226b7c0 100644
<font color="#FF6600">--- a/src/runtime/save.c</font>
<font color="#009900">+++ b/src/runtime/save.c</font>
<font color="#0000FF">@@ -16,7 +16,6 @@</font>
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 #include &lt;sys/file.h&gt;
 
 #include "sbcl.h"
diff --git a/src/runtime/thread.c b/src/runtime/thread.c
index 535263a..ae9f0ab 100644
<font color="#FF6600">--- a/src/runtime/thread.c</font>
<font color="#009900">+++ b/src/runtime/thread.c</font>
<font color="#0000FF">@@ -17,7 +17,8 @@</font>
 #ifndef LISP_FEATURE_WIN32
 #include &lt;sched.h&gt;
 #endif
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
<font color="#009900">+#include "interrupt.h"</font>
 #include &lt;stddef.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;sys/types.h&gt;
<font color="#0000FF">@@ -44,6 +45,9 @@</font>
 #include "interr.h"             /* for lose() */
 #include "alloc.h"
 #include "gc-internal.h"
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+#include "pseudo-atomic.h"</font>
<font color="#009900">+#endif</font>
 
 #ifdef LISP_FEATURE_WIN32
 /*
<font color="#0000FF">@@ -209,7 +213,11 @@ perform_thread_post_mortem(struct thread_post_mortem *post_mortem)</font>
         gc_assert(!pthread_join(post_mortem-&gt;os_thread, NULL));
         gc_assert(!pthread_attr_destroy(post_mortem-&gt;os_attr));
         free(post_mortem-&gt;os_attr);
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+        os_invalidate_free(post_mortem-&gt;os_address, THREAD_STRUCT_SIZE);</font>
<font color="#009900">+#else</font>
         os_invalidate(post_mortem-&gt;os_address, THREAD_STRUCT_SIZE);
<font color="#009900">+#endif</font>
         free(post_mortem);
     }
 }
<font color="#0000FF">@@ -267,6 +275,9 @@ new_thread_trampoline(struct thread *th)</font>
 {
     lispobj function;
     int result, lock_ret;
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    int i;</font>
<font color="#009900">+#endif</font>
 
     FSHOW((stderr,"/creating thread %lu\n", thread_self()));
     check_deferrables_blocked_or_lose(0);
<font color="#0000FF">@@ -313,8 +324,16 @@ new_thread_trampoline(struct thread *th)</font>
     pthread_mutex_destroy(th-&gt;state_lock);
     pthread_cond_destroy(th-&gt;state_cond);
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+  #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    pthread_mutex_destroy(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+  #endif</font>
<font color="#009900">+    os_invalidate_free((os_vm_address_t)th-&gt;interrupt_data,</font>
<font color="#009900">+                  (sizeof (struct interrupt_data)));</font>
<font color="#009900">+#else</font>
     os_invalidate((os_vm_address_t)th-&gt;interrupt_data,
                   (sizeof (struct interrupt_data)));
<font color="#009900">+#endif</font>
 
 #ifdef LISP_FEATURE_MACH_EXCEPTION_HANDLER
     FSHOW((stderr, "Deallocating mach port %x\n", THREAD_STRUCT_TO_EXCEPTION_PORT(th)));
<font color="#0000FF">@@ -337,11 +356,23 @@ new_thread_trampoline(struct thread *th)</font>
 static void
 free_thread_struct(struct thread *th)
 {
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    if (th-&gt;interrupt_data) {</font>
<font color="#009900">+        #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        pthread_mutex_destroy(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+        #endif</font>
<font color="#009900">+        os_invalidate_free((os_vm_address_t) th-&gt;interrupt_data,</font>
<font color="#009900">+                      (sizeof (struct interrupt_data)));</font>
<font color="#009900">+    }</font>
<font color="#009900">+    os_invalidate_free((os_vm_address_t) th-&gt;os_address,</font>
<font color="#009900">+                  THREAD_STRUCT_SIZE);</font>
<font color="#009900">+#else</font>
     if (th-&gt;interrupt_data)
         os_invalidate((os_vm_address_t) th-&gt;interrupt_data,
                       (sizeof (struct interrupt_data)));
     os_invalidate((os_vm_address_t) th-&gt;os_address,
                   THREAD_STRUCT_SIZE);
<font color="#009900">+#endif</font>
 }
 
 /* this is called from any other thread to create the new one, and
<font color="#0000FF">@@ -355,7 +386,7 @@ create_thread_struct(lispobj initial_function) {</font>
     struct thread *th=0;        /*  subdue gcc */
     void *spaces=0;
     void *aligned_spaces=0;
<font color="#FF6600">-#ifdef LISP_FEATURE_SB_THREAD</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD) || defined(LISP_FEATURE_WIN32)</font>
     unsigned int i;
 #endif
 
<font color="#0000FF">@@ -489,6 +520,11 @@ create_thread_struct(lispobj initial_function) {</font>
 #ifdef LISP_FEATURE_SB_THREAD
     bind_variable(STOP_FOR_GC_PENDING,NIL,th);
 #endif
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    bind_variable(GC_SAFE,NIL,th);</font>
<font color="#009900">+    bind_variable(IN_SAFEPOINT,NIL,th);</font>
<font color="#009900">+    bind_variable(DISABLE_SAFEPOINTS,NIL,th);</font>
<font color="#009900">+#endif</font>
 #ifndef LISP_FEATURE_C_STACK_IS_CONTROL_STACK
     access_control_stack_pointer(th)=th-&gt;control_stack_start;
 #endif
<font color="#0000FF">@@ -505,6 +541,11 @@ create_thread_struct(lispobj initial_function) {</font>
     th-&gt;interrupt_data-&gt;allocation_trap_context = 0;
 #endif
     th-&gt;no_tls_value_marker=initial_function;
<font color="#009900">+    </font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    th-&gt;interrupt_data-&gt;win32_data.interrupts_count = 0;</font>
<font color="#009900">+    pthread_mutex_init(&amp;th-&gt;interrupt_data-&gt;win32_data.lock, NULL);</font>
<font color="#009900">+#endif</font>
 
     th-&gt;stepping = NIL;
     return th;
<font color="#0000FF">@@ -560,8 +601,12 @@ boolean create_os_thread(struct thread *th,os_thread_t *kid_tid)</font>
     if((initcode = pthread_attr_init(th-&gt;os_attr)) ||
        /* call_into_lisp_first_time switches the stack for the initial
         * thread. For the others, we use this. */
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+       (pthread_attr_setstacksize(th-&gt;os_attr, thread_control_stack_size)) ||</font>
<font color="#009900">+#else</font>
        (pthread_attr_setstack(th-&gt;os_attr,th-&gt;control_stack_start,
                               thread_control_stack_size)) ||
<font color="#009900">+#endif</font>
        (retcode = pthread_create
         (kid_tid,th-&gt;os_attr,(void *(*)(void *))new_thread_trampoline,th))) {
         FSHOW_SIGNAL((stderr, "init = %d\n", initcode));
<font color="#0000FF">@@ -608,6 +653,612 @@ os_thread_t create_thread(lispobj initial_function) {</font>
  * it's in the middle of allocation) then waits for another SIG_STOP_FOR_GC.
  */
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+</font>
<font color="#009900">+struct threads_suspend_info suspend_info = {</font>
<font color="#009900">+  0, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER,</font>
<font color="#009900">+  SUSPEND_REASON_NONE, 0, NULL, NULL</font>
<font color="#009900">+};</font>
<font color="#009900">+</font>
<font color="#009900">+// returns: 0 if all is ok</font>
<font color="#009900">+// -1 if max interrupts reached</font>
<font color="#009900">+int schedule_thread_interrupt(struct thread * th, lispobj interrupt_fn)</font>
<font color="#009900">+{</font>
<font color="#009900">+  odprintf("schedule_thread_interrupt(0x%p, 0x%p) begin", th-&gt;os_thread, interrupt_fn);</font>
<font color="#009900">+  pthread_mutex_lock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+  if (th-&gt;interrupt_data-&gt;win32_data.interrupts_count == MAX_INTERRUPTS) {</font>
<font color="#009900">+    pthread_mutex_unlock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+    return -1;</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    ++th-&gt;interrupt_data-&gt;win32_data.interrupts_count;</font>
<font color="#009900">+    th-&gt;interrupt_data-&gt;win32_data.interrupts[th-&gt;interrupt_data-&gt;win32_data.interrupts_count - 1] = interrupt_fn;</font>
<font color="#009900">+    pthread_mutex_unlock(&amp;th-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+    SetSymbolValue(INTERRUPT_PENDING, T, th);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  odprintf("schedule_thread_interrupt(0x%p, 0x%p) end", th-&gt;os_thread, interrupt_fn);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+const char * t_nil_str(lispobj value)</font>
<font color="#009900">+{</font>
<font color="#009900">+	if (value == T) return "T";</font>
<font color="#009900">+	if (value == NIL) return "NIL";</font>
<font color="#009900">+	return "?";</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void lock_suspend_info(const char * file, int line)</font>
<font color="#009900">+{</font>
<font color="#009900">+  odprintf("locking suspend_info.lock (%s:%d)", file, line);</font>
<font color="#009900">+  pthread_mutex_lock(&amp;suspend_info.lock);</font>
<font color="#009900">+  odprintf("locked suspend_info.lock (%s:%d)", file, line);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void unlock_suspend_info(const char * file, int line)</font>
<font color="#009900">+{</font>
<font color="#009900">+  odprintf("unlocking suspend_info.lock (%s:%d)", file, line);</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;suspend_info.lock);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void roll_thread_to_safepoint(struct thread * thread)</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * p;</font>
<font color="#009900">+  odprintf("roll_thread_to_safepoint(0x%p) begin", thread-&gt;os_thread);</font>
<font color="#009900">+  pthread_mutex_lock(&amp;all_threads_lock);</font>
<font color="#009900">+  odprintf("all_threads_lock taken");</font>
<font color="#009900">+  pthread_mutex_lock(&amp;suspend_info.world_lock);</font>
<font color="#009900">+  odprintf("world_lock taken");</font>
<font color="#009900">+  </font>
<font color="#009900">+  lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  suspend_info.reason = SUSPEND_REASON_INTERRUPT;</font>
<font color="#009900">+  suspend_info.interrupted_thread = thread;</font>
<font color="#009900">+  suspend_info.phase = 1;</font>
<font color="#009900">+  suspend_info.suspend = 1;</font>
<font color="#009900">+  unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  </font>
<font color="#009900">+  odprintf("unmapping gc page");</font>
<font color="#009900">+  </font>
<font color="#009900">+  unmap_gc_page();</font>
<font color="#009900">+  </font>
<font color="#009900">+  odprintf("unmapped gc page, doing interrupt phase 1");</font>
<font color="#009900">+  </font>
<font color="#009900">+  // Phase 1: Make sure that th is in gc-safe code or noted the need to interrupt</font>
<font color="#009900">+  if (SymbolValue(GC_SAFE, thread) == NIL) {</font>
<font color="#009900">+    wait_for_thread_state_change(thread, STATE_RUNNING);</font>
<font color="#009900">+  } </font>
<font color="#009900">+  </font>
<font color="#009900">+  odprintf("mapping gc page");</font>
<font color="#009900">+  </font>
<font color="#009900">+  map_gc_page();</font>
<font color="#009900">+  </font>
<font color="#009900">+  odprintf("mapped gc page");</font>
<font color="#009900">+  </font>
<font color="#009900">+  lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  suspend_info.suspend = 0;</font>
<font color="#009900">+  unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  odprintf("mapped gc page, iterating over threads and waking them");</font>
<font color="#009900">+  </font>
<font color="#009900">+  for (p = all_threads; p; p = p-&gt;next) {</font>
<font color="#009900">+    if (thread_state(p) != STATE_DEAD)</font>
<font color="#009900">+      set_thread_state(p, STATE_RUNNING);</font>
<font color="#009900">+  }</font>
<font color="#009900">+</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;suspend_info.world_lock);</font>
<font color="#009900">+  pthread_mutex_unlock(&amp;all_threads_lock);</font>
<font color="#009900">+  </font>
<font color="#009900">+  odprintf("roll_thread_to_safepoint(0x%p) end", thread-&gt;os_thread);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int check_pending_interrupts();</font>
<font color="#009900">+</font>
<font color="#009900">+// returns: 0 if interrupt is queued</font>
<font color="#009900">+// -1 if max interrupts reached</font>
<font color="#009900">+int interrupt_lisp_thread(struct thread * thread, lispobj interrupt_fn)</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  if (schedule_thread_interrupt(thread, interrupt_fn) != 0) {</font>
<font color="#009900">+    return -1;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  </font>
<font color="#009900">+  if (self == thread) {</font>
<font color="#009900">+    check_pending_interrupts();</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    roll_thread_to_safepoint(thread);</font>
<font color="#009900">+  }</font>
<font color="#009900">+  </font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+int thread_may_gc();</font>
<font color="#009900">+int thread_may_suspend_for_gc();</font>
<font color="#009900">+</font>
<font color="#009900">+// returns 0 if skipped, 1 otherwise</font>
<font color="#009900">+int check_pending_gc()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  if (SymbolValue(GC_PENDING, self) == T) {</font>
<font color="#009900">+    if (thread_may_gc()) {</font>
<font color="#009900">+      SetSymbolValue(GC_PENDING, NIL, self);</font>
<font color="#009900">+      sigset_t old_sigmask;</font>
<font color="#009900">+      block_blockable_signals(0, &amp;old_sigmask);</font>
<font color="#009900">+      CONTEXT win32_ctx;</font>
<font color="#009900">+      os_context_t ctx;</font>
<font color="#009900">+      ctx.win32_context = &amp;win32_ctx;</font>
<font color="#009900">+      pthread_sigmask(SIG_BLOCK, NULL, &amp;ctx.sigmask);</font>
<font color="#009900">+      maybe_gc(&amp;ctx);</font>
<font color="#009900">+      pthread_sigmask(SIG_SETMASK, &amp;old_sigmask, NULL);</font>
<font color="#009900">+      return 1;</font>
<font color="#009900">+    }</font>
<font color="#009900">+  }</font>
<font color="#009900">+  return 0;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+// returns 0 if skipped, 1 otherwise</font>
<font color="#009900">+int check_pending_interrupts()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * p = arch_os_get_current_thread();</font>
<font color="#009900">+  sigset_t sigset;</font>
<font color="#009900">+  int done = 0;</font>
<font color="#009900">+  done |= check_pending_gc();</font>
<font color="#009900">+  if (p-&gt;interrupt_data-&gt;win32_data.interrupts_count == 0) {</font>
<font color="#009900">+    return done;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  odprintf("In check_pending_interrupts, have %d interrupts", p-&gt;interrupt_data-&gt;win32_data.interrupts_count);</font>
<font color="#009900">+  get_current_sigmask(&amp;sigset);</font>
<font color="#009900">+  if (sigismember(&amp;sigset, SIGHUP)) {</font>
<font color="#009900">+    if (SymbolValue(INTERRUPT_PENDING, p) == NIL) {</font>
<font color="#009900">+      odprintf("SIGHUP is blocked, setting INTERRUPT_PENDING");</font>
<font color="#009900">+      SetSymbolValue(INTERRUPT_PENDING, T, p);</font>
<font color="#009900">+      pthread_np_add_pending_signal(p-&gt;os_thread, SIGHUP);</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+    }</font>
<font color="#009900">+    return done;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  </font>
<font color="#009900">+  if (SymbolValue(INTERRUPTS_ENABLED, p) == NIL) {</font>
<font color="#009900">+    odprintf("INTERRUPTS_ENABLED = NIL, setting INTERRUPT_PENDING");</font>
<font color="#009900">+    if (p-&gt;interrupt_data-&gt;win32_data.interrupts_count &gt; 0 &amp;&amp; SymbolValue(INTERRUPT_PENDING, p) == NIL) {</font>
<font color="#009900">+      SetSymbolValue(INTERRUPT_PENDING, T, p);</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+    }</font>
<font color="#009900">+    return done;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  SetSymbolValue(INTERRUPT_PENDING, NIL, p);</font>
<font color="#009900">+  </font>
<font color="#009900">+  while (1) {</font>
<font color="#009900">+    pthread_mutex_lock(&amp;p-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+    if (p-&gt;interrupt_data-&gt;win32_data.interrupts_count &gt; 0) {</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+      odprintf("Have %d interrupts", p-&gt;interrupt_data-&gt;win32_data.interrupts_count);</font>
<font color="#009900">+			lispobj objs[MAX_INTERRUPTS];</font>
<font color="#009900">+			int i, n;</font>
<font color="#009900">+			n = p-&gt;interrupt_data-&gt;win32_data.interrupts_count;</font>
<font color="#009900">+			for (i = 0; i &lt; p-&gt;interrupt_data-&gt;win32_data.interrupts_count; ++i)</font>
<font color="#009900">+				objs[i] = p-&gt;interrupt_data-&gt;win32_data.interrupts[i];</font>
<font color="#009900">+</font>
<font color="#009900">+			p-&gt;interrupt_data-&gt;win32_data.interrupts_count = 0;</font>
<font color="#009900">+      pthread_mutex_unlock(&amp;p-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+      for (i = 0; i &lt; n; ++i) {</font>
<font color="#009900">+				lispobj fn = objs[i];</font>
<font color="#009900">+				objs[i] = 0;</font>
<font color="#009900">+        odprintf("calling interrupt function 0x%p", fn);</font>
<font color="#009900">+				funcall0(fn);</font>
<font color="#009900">+				fn = 0;</font>
<font color="#009900">+			}</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      odprintf("No more interrupts", p-&gt;interrupt_data-&gt;win32_data.interrupts_count);</font>
<font color="#009900">+      pthread_mutex_unlock(&amp;p-&gt;interrupt_data-&gt;win32_data.lock);</font>
<font color="#009900">+      break;</font>
<font color="#009900">+    }</font>
<font color="#009900">+  }</font>
<font color="#009900">+  </font>
<font color="#009900">+  return done;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+</font>
<font color="#009900">+void gc_enter_safe_region()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  int errorCode = GetLastError();</font>
<font color="#009900">+  bind_variable(GC_SAFE, thread_may_suspend_for_gc() ? T : NIL, self);</font>
<font color="#009900">+  gc_safepoint();</font>
<font color="#009900">+  SetLastError(errorCode);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void gc_enter_unsafe_region()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  int errorCode = GetLastError();</font>
<font color="#009900">+  bind_variable(GC_SAFE, NIL, self);</font>
<font color="#009900">+  gc_safepoint();</font>
<font color="#009900">+  SetLastError(errorCode);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void gc_leave_region()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  int errorCode = GetLastError();</font>
<font color="#009900">+  unbind_variable(GC_SAFE, self);</font>
<font color="#009900">+  gc_safepoint();</font>
<font color="#009900">+  SetLastError(errorCode);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void safepoint_cycle_state(int state)</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  set_thread_state(self, state);</font>
<font color="#009900">+  unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  wait_for_thread_state_change(self, state);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void suspend()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  safepoint_cycle_state(STATE_SUSPENDED);</font>
<font color="#009900">+  SetSymbolValue(STOP_FOR_GC_PENDING, NIL, self);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void suspend_briefly()</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (suspend_info.phase == 1 || suspend_info.reason == SUSPEND_REASON_INTERRUPT) {</font>
<font color="#009900">+    safepoint_cycle_state(STATE_SUSPENDED_BRIEFLY);</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int thread_may_gc()</font>
<font color="#009900">+{</font>
<font color="#009900">+  // Thread may gc if all of these are true:</font>
<font color="#009900">+  // 1) SIG_STOP_FOR_GC is unblocked</font>
<font color="#009900">+  // 2) GC_INHIBIT is NIL</font>
<font color="#009900">+  // 3) INTERRUPTS_ENABLED is not-NIL</font>
<font color="#009900">+  // 4) !pseudo_atomic</font>
<font color="#009900">+</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  </font>
<font color="#009900">+  sigset_t ss;</font>
<font color="#009900">+  </font>
<font color="#009900">+  pthread_sigmask(SIG_BLOCK, NULL, &amp;ss);</font>
<font color="#009900">+  if (sigismember(&amp;ss, SIG_STOP_FOR_GC)) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  if (SymbolValue(GC_INHIBIT, self) != NIL) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  if (SymbolValue(GC_PENDING, self) != T &amp;&amp; SymbolValue(GC_PENDING, self) != NIL) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  if (get_pseudo_atomic_atomic(self)) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  return 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int thread_may_suspend_for_gc()</font>
<font color="#009900">+{</font>
<font color="#009900">+  // Thread may gc if all of these are true:</font>
<font color="#009900">+  // 1) SIG_STOP_FOR_GC is unblocked</font>
<font color="#009900">+  // 2) GC_INHIBIT is NIL</font>
<font color="#009900">+  // 3) INTERRUPTS_ENABLED is not-NIL</font>
<font color="#009900">+  // 4) !pseudo_atomic</font>
<font color="#009900">+</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  </font>
<font color="#009900">+  sigset_t ss;</font>
<font color="#009900">+  </font>
<font color="#009900">+  pthread_sigmask(SIG_BLOCK, NULL, &amp;ss);</font>
<font color="#009900">+  if (sigismember(&amp;ss, SIG_STOP_FOR_GC)) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  if (SymbolValue(GC_INHIBIT, self) != NIL) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  </font>
<font color="#009900">+  if (get_pseudo_atomic_atomic(self)) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  return 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int thread_may_interrupt()</font>
<font color="#009900">+{</font>
<font color="#009900">+  // Thread may be interrupted if all of these are true:</font>
<font color="#009900">+  // 1) SIGHUP is unblocked</font>
<font color="#009900">+  // 2) INTERRUPTS_ENABLED is not-nil</font>
<font color="#009900">+  // 3) !pseudo_atomic</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  </font>
<font color="#009900">+  sigset_t ss;</font>
<font color="#009900">+  pthread_sigmask(SIG_BLOCK, NULL, &amp;ss);</font>
<font color="#009900">+  if (sigismember(&amp;ss, SIGHUP))</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+    </font>
<font color="#009900">+  if (SymbolValue(INTERRUPTS_ENABLED, self) == NIL)</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  </font>
<font color="#009900">+  if (get_pseudo_atomic_atomic(self)) {</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  </font>
<font color="#009900">+  return 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+// returns: 0 if skipped, 1 otherwise</font>
<font color="#009900">+int maybe_ack_gc_poll()</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  if (!suspend_info.suspend) return 0;</font>
<font color="#009900">+  odprintf("maybe_ack_gc_poll, suspend_info.suspend was set, locking suspend_info");</font>
<font color="#009900">+  lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  odprintf("maybe_ack_gc_poll, suspend_info.suspend is %d, gc_thread = 0x%p", suspend_info.suspend, suspend_info.gc_thread == self ? "me" : "notme");</font>
<font color="#009900">+  if (!suspend_info.suspend) {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_GC</font>
<font color="#009900">+      &amp;&amp; self != suspend_info.gc_thread</font>
<font color="#009900">+      &amp;&amp; suspend_info.phase == 1</font>
<font color="#009900">+     ) {</font>
<font color="#009900">+    suspend_briefly();</font>
<font color="#009900">+    SetSymbolValue(STOP_FOR_GC_PENDING, T, self);</font>
<font color="#009900">+    SetSymbolValue(INTERRUPT_PENDING, T, self);</font>
<font color="#009900">+  } else</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_INTERRUPT) {</font>
<font color="#009900">+    if (suspend_info.interrupted_thread == self &amp;&amp; thread_may_interrupt()) {</font>
<font color="#009900">+      suspend();</font>
<font color="#009900">+      check_pending_interrupts();</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      suspend_briefly();</font>
<font color="#009900">+    }</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  return 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+// returns 0 if skipped, 1 otherwise</font>
<font color="#009900">+int maybe_suspend_for_gc()</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (!suspend_info.suspend) return 0;</font>
<font color="#009900">+  lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  if (!suspend_info.suspend) {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_GC &amp;&amp; suspend_info.phase == 2) {</font>
<font color="#009900">+    if (self == suspend_info.gc_thread) {</font>
<font color="#009900">+      unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+      return 0;</font>
<font color="#009900">+		} else {</font>
<font color="#009900">+			if (thread_may_suspend_for_gc()) {</font>
<font color="#009900">+				suspend();</font>
<font color="#009900">+				//check_pending_interrupts();</font>
<font color="#009900">+			} else {</font>
<font color="#009900">+        unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+        return 0;</font>
<font color="#009900">+      }</font>
<font color="#009900">+		}</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  return 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+// rreturns 0 if skipped, 1 otherwise</font>
<font color="#009900">+int maybe_wait_until_gc_ends()</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (!suspend_info.suspend) return 0;</font>
<font color="#009900">+  lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  if (!suspend_info.suspend) {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_GCING</font>
<font color="#009900">+      &amp;&amp; suspend_info.gc_thread != self</font>
<font color="#009900">+     ) {</font>
<font color="#009900">+    if (thread_may_suspend_for_gc()) {</font>
<font color="#009900">+      suspend();</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+      lose("suspend_info.reason = SUSPEND_REASON_GCING, !thread_may_suspend_for_gc()");</font>
<font color="#009900">+    }</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  return 1;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void gc_safepoint()</font>
<font color="#009900">+{</font>
<font color="#009900">+  DWORD lasterror = GetLastError();</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  int done = 0;</font>
<font color="#009900">+  </font>
<font color="#009900">+  again:</font>
<font color="#009900">+  </font>
<font color="#009900">+  odprintf("safepoint begins");</font>
<font color="#009900">+  </font>
<font color="#009900">+  if (!get_pseudo_atomic_atomic(self) &amp;&amp; get_pseudo_atomic_interrupted(self))</font>
<font color="#009900">+    clear_pseudo_atomic_interrupted(self);</font>
<font color="#009900">+  </font>
<font color="#009900">+  done |= maybe_ack_gc_poll();</font>
<font color="#009900">+  done |= maybe_suspend_for_gc();</font>
<font color="#009900">+  done |= maybe_wait_until_gc_ends();</font>
<font color="#009900">+</font>
<font color="#009900">+  if (SymbolValue(IN_SAFEPOINT, self) != NIL) {</font>
<font color="#009900">+    odprintf("IN_SAFEPOINT, safepoint ends");</font>
<font color="#009900">+    goto maybe_again;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (SymbolValue(DISABLE_SAFEPOINTS, self) != NIL) {</font>
<font color="#009900">+    odprintf("DISABLE_SAFEPOINTS, safepoint ends");</font>
<font color="#009900">+    goto maybe_again;</font>
<font color="#009900">+  }</font>
<font color="#009900">+    </font>
<font color="#009900">+  bind_variable(IN_SAFEPOINT, T, self);</font>
<font color="#009900">+  int bound = 1;</font>
<font color="#009900">+  </font>
<font color="#009900">+  if (!suspend_info.suspend) {</font>
<font color="#009900">+    unbind_variable(IN_SAFEPOINT, self);</font>
<font color="#009900">+    done |= check_pending_interrupts();</font>
<font color="#009900">+    SetSymbolValue(STOP_FOR_GC_PENDING, NIL, self);</font>
<font color="#009900">+    odprintf("safepoint ends");</font>
<font color="#009900">+    goto maybe_again;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+  if (!suspend_info.suspend) {</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    unbind_variable(IN_SAFEPOINT, self);</font>
<font color="#009900">+    done |= check_pending_interrupts();</font>
<font color="#009900">+    SetSymbolValue(STOP_FOR_GC_PENDING, NIL, self);</font>
<font color="#009900">+    odprintf("safepoint ends");</font>
<font color="#009900">+    goto maybe_again;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_GCING) {</font>
<font color="#009900">+    if (suspend_info.gc_thread == self) {</font>
<font color="#009900">+      unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    } else</font>
<font color="#009900">+    if (thread_may_suspend_for_gc()) {</font>
<font color="#009900">+      suspend();</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+      lose("suspend_info.reason = SUSPEND_REASON_GCING, !thread_may_suspend_for_gc()");</font>
<font color="#009900">+    }</font>
<font color="#009900">+  } else</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_GC) {</font>
<font color="#009900">+    if (self == suspend_info.gc_thread) {</font>
<font color="#009900">+      unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    } else</font>
<font color="#009900">+    if (suspend_info.phase == 1) {</font>
<font color="#009900">+			if (thread_may_suspend_for_gc()) {</font>
<font color="#009900">+				suspend();</font>
<font color="#009900">+        bound = 0;</font>
<font color="#009900">+        unbind_variable(IN_SAFEPOINT, self);</font>
<font color="#009900">+				check_pending_interrupts();</font>
<font color="#009900">+				SetSymbolValue(STOP_FOR_GC_PENDING, NIL, self);</font>
<font color="#009900">+        done = 1;</font>
<font color="#009900">+			} else {</font>
<font color="#009900">+				suspend_briefly();</font>
<font color="#009900">+				SetSymbolValue(STOP_FOR_GC_PENDING, T, self);</font>
<font color="#009900">+				SetSymbolValue(INTERRUPT_PENDING, T, self);</font>
<font color="#009900">+        done = 1;</font>
<font color="#009900">+			}</font>
<font color="#009900">+		} else {</font>
<font color="#009900">+			if (thread_may_suspend_for_gc()) {</font>
<font color="#009900">+				suspend();</font>
<font color="#009900">+        bound = 0;</font>
<font color="#009900">+        unbind_variable(IN_SAFEPOINT, self);</font>
<font color="#009900">+				check_pending_interrupts();</font>
<font color="#009900">+        done = 1;</font>
<font color="#009900">+			} else {</font>
<font color="#009900">+        unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+      }</font>
<font color="#009900">+		}</font>
<font color="#009900">+  } else</font>
<font color="#009900">+  if (suspend_info.reason == SUSPEND_REASON_INTERRUPT) {</font>
<font color="#009900">+    if (suspend_info.interrupted_thread != self) {</font>
<font color="#009900">+      suspend_briefly();</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+    } else</font>
<font color="#009900">+    if (thread_may_interrupt()) {</font>
<font color="#009900">+      suspend();</font>
<font color="#009900">+      bound = 0;</font>
<font color="#009900">+      unbind_variable(IN_SAFEPOINT, self);</font>
<font color="#009900">+      check_pending_interrupts();</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+    } else {</font>
<font color="#009900">+      suspend_briefly();</font>
<font color="#009900">+      done = 1;</font>
<font color="#009900">+    }</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    lose("in gc_safepoint, fell through");</font>
<font color="#009900">+  }</font>
<font color="#009900">+  if (bound)</font>
<font color="#009900">+    unbind_variable(IN_SAFEPOINT, self);</font>
<font color="#009900">+  odprintf("safepoint ends");</font>
<font color="#009900">+  </font>
<font color="#009900">+  maybe_again:</font>
<font color="#009900">+  if (done) {</font>
<font color="#009900">+    done = 0;</font>
<font color="#009900">+    goto again;</font>
<font color="#009900">+  }</font>
<font color="#009900">+  SetLastError(lasterror);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void pthread_np_pending_signal_handler(int signum)</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (signum == SIG_STOP_FOR_GC || signum == SIGHUP) {</font>
<font color="#009900">+    gc_safepoint();</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+lispobj fn_by_pc(unsigned int pc)</font>
<font color="#009900">+{</font>
<font color="#009900">+  lispobj obj = (lispobj)search_read_only_space((void*)pc);</font>
<font color="#009900">+  if (!obj)</font>
<font color="#009900">+    obj = (lispobj)search_static_space((void*)pc);</font>
<font color="#009900">+  if (!obj)</font>
<font color="#009900">+    obj = (lispobj)search_dynamic_space((void*)pc);</font>
<font color="#009900">+  return obj;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int pc_in_lisp_code(unsigned int pc)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return</font>
<font color="#009900">+    search_read_only_space((void*)pc) != NULL ||</font>
<font color="#009900">+    search_static_space((void*)pc) != NULL ||</font>
<font color="#009900">+    search_dynamic_space((void*)pc) != NULL;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int thread_get_pc(struct thread *th)</font>
<font color="#009900">+{</font>
<font color="#009900">+  CONTEXT ctx;</font>
<font color="#009900">+  pthread_np_get_thread_context(th-&gt;os_thread, &amp;ctx);</font>
<font color="#009900">+  return ctx.Eip;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int thread_get_pc_susp(struct thread *th)</font>
<font color="#009900">+{</font>
<font color="#009900">+  CONTEXT ctx;</font>
<font color="#009900">+  pthread_np_suspend(th-&gt;os_thread);</font>
<font color="#009900">+  pthread_np_get_thread_context(th-&gt;os_thread, &amp;ctx);</font>
<font color="#009900">+  pthread_np_resume(th-&gt;os_thread);</font>
<font color="#009900">+  return ctx.Eip;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+int thread_in_lisp_code(struct thread *th)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return pc_in_lisp_code(thread_get_pc(th));</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+const char * fn_name(lispobj fn)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return "unknown";</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+const char * t_nil_s(lispobj symbol)</font>
<font color="#009900">+{</font>
<font color="#009900">+  struct tread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  return t_nil_str(SymbolValue(symbol, self));</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void log_gc_state(const char * msg)</font>
<font color="#009900">+{</font>
<font color="#009900">+  odprintf(msg);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 /* To avoid deadlocks when gc stops the world all clients of each
  * mutex must enable or disable SIG_STOP_FOR_GC for the duration of
  * holding the lock, but they must agree on which. */
<font color="#0000FF">@@ -615,6 +1266,10 @@ void gc_stop_the_world()</font>
 {
     struct thread *p,*th=arch_os_get_current_thread();
     int status, lock_ret;
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+    odprintf("stopping the world");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+    </font>
 #ifdef LOCK_CREATE_THREAD
     /* KLUDGE: Stopping the thread during pthread_create() causes deadlock
      * on FreeBSD. */
<font color="#0000FF">@@ -623,18 +1278,47 @@ void gc_stop_the_world()</font>
     gc_assert(lock_ret == 0);
     FSHOW_SIGNAL((stderr,"/gc_stop_the_world:got create_thread_lock\n"));
 #endif
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    odprintf("taking world lock");</font>
<font color="#009900">+    pthread_mutex_lock(&amp;suspend_info.world_lock);</font>
<font color="#009900">+    </font>
<font color="#009900">+    odprintf("phase 1 begins");</font>
<font color="#009900">+    odprintf("taking lock");</font>
<font color="#009900">+    lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    odprintf("took the lock");</font>
<font color="#009900">+    suspend_info.reason = SUSPEND_REASON_GC;</font>
<font color="#009900">+    suspend_info.gc_thread = arch_os_get_current_thread();</font>
<font color="#009900">+    suspend_info.phase = 1;</font>
<font color="#009900">+    suspend_info.suspend = 1;</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    </font>
<font color="#009900">+    unmap_gc_page();</font>
<font color="#009900">+    odprintf("gc_page unmapped");</font>
<font color="#009900">+</font>
<font color="#009900">+    odprintf("taking all_threads_lock");</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
     FSHOW_SIGNAL((stderr,"/gc_stop_the_world:waiting on lock\n"));
     /* keep threads from starting while the world is stopped. */
<font color="#FF6600">-    lock_ret = pthread_mutex_lock(&amp;all_threads_lock);      \</font>
<font color="#009900">+    lock_ret = pthread_mutex_lock(&amp;all_threads_lock);</font>
     gc_assert(lock_ret == 0);
 
     FSHOW_SIGNAL((stderr,"/gc_stop_the_world:got lock\n"));
     /* stop all other threads by sending them SIG_STOP_FOR_GC */
<font color="#009900">+    /* Phase 1, make sure that all threads are: 1) have noted the need to interrupt; or 2) in gc-safe code */</font>
<font color="#009900">+    </font>
     for(p=all_threads; p; p=p-&gt;next) {
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+        odprintf("looking at 0x%p", p-&gt;os_thread);</font>
<font color="#009900">+#endif</font>
         gc_assert(p-&gt;os_thread != 0);
         FSHOW_SIGNAL((stderr,"/gc_stop_the_world: thread=%lu, state=%x\n",
                       p-&gt;os_thread, thread_state(p)));
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+        odprintf("looking at 0x%p, state is %s, GC_SAFE is %s", p-&gt;os_thread, get_thread_state_as_string(p), t_nil_str(SymbolValue(GC_SAFE, p)));</font>
<font color="#009900">+#endif</font>
         if((p!=th) &amp;&amp; ((thread_state(p)==STATE_RUNNING))) {
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
             FSHOW_SIGNAL((stderr,"/gc_stop_the_world: suspending thread %lu\n",
                           p-&gt;os_thread));
             /* We already hold all_thread_lock, P can become DEAD but
<font color="#0000FF">@@ -647,11 +1331,30 @@ void gc_stop_the_world()</font>
                 lose("cannot send suspend thread=%lu: %d, %s\n",
                      p-&gt;os_thread,status,strerror(status));
             }
<font color="#009900">+#else</font>
<font color="#009900">+          if (SymbolValue(GC_SAFE, p) == T) continue;</font>
<font color="#009900">+          odprintf("waiting for 0x%p to change state from RUNNING");</font>
<font color="#009900">+          wait_for_thread_state_change(p, STATE_RUNNING);</font>
<font color="#009900">+          odprintf("0x%p has changed state to %s", p-&gt;os_thread, get_thread_state_as_string(p));</font>
<font color="#009900">+#endif</font>
         }
     }
<font color="#009900">+</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    /* Phase 2, wait until all threads 1) suspend themselves; or 2) are in gc-safe code */</font>
<font color="#009900">+    </font>
<font color="#009900">+    odprintf("phase 2");</font>
<font color="#009900">+    </font>
<font color="#009900">+    lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    map_gc_page();</font>
<font color="#009900">+    suspend_info.phase = 2;</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+#endif</font>
<font color="#009900">+    </font>
     FSHOW_SIGNAL((stderr,"/gc_stop_the_world:signals sent\n"));
     for(p=all_threads;p;p=p-&gt;next) {
         if (p!=th) {
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
             FSHOW_SIGNAL
                 ((stderr,
                   "/gc_stop_the_world: waiting for thread=%lu: state=%x\n",
<font color="#0000FF">@@ -659,9 +1362,26 @@ void gc_stop_the_world()</font>
             wait_for_thread_state_change(p, STATE_RUNNING);
             if (p-&gt;state == STATE_RUNNING)
                 lose("/gc_stop_the_world: unexpected state");
<font color="#009900">+#else</font>
<font color="#009900">+            odprintf("looking at 0x%p, state is %s, GC_SAFE is %s", p-&gt;os_thread, get_thread_state_as_string(p), t_nil_str(SymbolValue(GC_SAFE, p)));</font>
<font color="#009900">+            if (SymbolValue(GC_SAFE, p) == NIL) {</font>
<font color="#009900">+              if (thread_state(p) == STATE_SUSPENDED_BRIEFLY) {</font>
<font color="#009900">+                set_thread_state(p, STATE_RUNNING);</font>
<font color="#009900">+                odprintf("waiting for 0x%p to change state from RUNNING");</font>
<font color="#009900">+                wait_for_thread_state_change(p, STATE_RUNNING);</font>
<font color="#009900">+              }</font>
<font color="#009900">+            }</font>
<font color="#009900">+            odprintf("looking at 0x%p, state is %s, GC_SAFE is %s", p-&gt;os_thread, get_thread_state_as_string(p), t_nil_str(SymbolValue(GC_SAFE, p)));</font>
<font color="#009900">+#endif</font>
         }
     }
     FSHOW_SIGNAL((stderr,"/gc_stop_the_world:end\n"));
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    suspend_info.reason = SUSPEND_REASON_GCING;</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    odprintf("stopped the world");</font>
<font color="#009900">+#endif</font>
 }
 
 void gc_start_the_world()
<font color="#0000FF">@@ -673,15 +1393,29 @@ void gc_start_the_world()</font>
      * all_threads, but it won't have been stopped so won't need
      * restarting */
     FSHOW_SIGNAL((stderr,"/gc_start_the_world:begin\n"));
<font color="#009900">+  </font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    odprintf("starting the world");</font>
<font color="#009900">+</font>
<font color="#009900">+    lock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+    suspend_info.suspend = 0;</font>
<font color="#009900">+    unlock_suspend_info(__FILE__, __LINE__);</font>
<font color="#009900">+#endif</font>
<font color="#009900">+    </font>
     for(p=all_threads;p;p=p-&gt;next) {
         gc_assert(p-&gt;os_thread!=0);
         if (p!=th) {
             lispobj state = thread_state(p);
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+            odprintf("looking at 0x%p, state is %s, GC_SAFE is %s", p-&gt;os_thread, get_thread_state_as_string(p), t_nil_str(SymbolValue(GC_SAFE, p)));</font>
<font color="#009900">+#endif</font>
             if (state != STATE_DEAD) {
<font color="#009900">+#ifndef LISP_FEATURE_WIN32</font>
                 if(state != STATE_SUSPENDED) {
                     lose("gc_start_the_world: wrong thread state is %d\n",
                          fixnum_value(state));
                 }
<font color="#009900">+#endif</font>
                 FSHOW_SIGNAL((stderr, "/gc_start_the_world: resuming %lu\n",
                               p-&gt;os_thread));
                 set_thread_state(p, STATE_RUNNING);
<font color="#0000FF">@@ -691,11 +1425,17 @@ void gc_start_the_world()</font>
 
     lock_ret = pthread_mutex_unlock(&amp;all_threads_lock);
     gc_assert(lock_ret == 0);
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+    pthread_mutex_unlock(&amp;suspend_info.world_lock);</font>
<font color="#009900">+#endif</font>
 #ifdef LOCK_CREATE_THREAD
     lock_ret = pthread_mutex_unlock(&amp;create_thread_lock);
     gc_assert(lock_ret == 0);
 #endif
 
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+    odprintf("started the world");</font>
<font color="#009900">+#endif</font>
     FSHOW_SIGNAL((stderr,"/gc_start_the_world:end\n"));
 }
 #endif
<font color="#0000FF">@@ -704,7 +1444,12 @@ int</font>
 thread_yield()
 {
 #ifdef LISP_FEATURE_SB_THREAD
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    SwitchToThread();</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+#else</font>
     return sched_yield();
<font color="#009900">+#endif</font>
 #else
     return 0;
 #endif
<font color="#0000FF">@@ -730,6 +1475,9 @@ int</font>
 kill_safely(os_thread_t os_thread, int signal)
 {
     FSHOW_SIGNAL((stderr,"/kill_safely: %lu, %d\n", os_thread, signal));
<font color="#009900">+#if defined(LISP_FEATURE_WIN32)</font>
<font color="#009900">+    return 0;</font>
<font color="#009900">+#else</font>
     {
 #ifdef LISP_FEATURE_SB_THREAD
         sigset_t oldset;
<font color="#0000FF">@@ -776,4 +1524,5 @@ kill_safely(os_thread_t os_thread, int signal)</font>
         }
 #endif
     }
<font color="#009900">+#endif</font>
 }
diff --git a/src/runtime/thread.h b/src/runtime/thread.h
index 3de5415..55d2e5a 100644
<font color="#FF6600">--- a/src/runtime/thread.h</font>
<font color="#009900">+++ b/src/runtime/thread.h</font>
<font color="#0000FF">@@ -22,9 +22,30 @@ struct alloc_region { };</font>
 #define STATE_RUNNING (make_fixnum(1))
 #define STATE_SUSPENDED (make_fixnum(2))
 #define STATE_DEAD (make_fixnum(3))
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+#define STATE_SUSPENDED_BRIEFLY (make_fixnum(4))</font>
<font color="#009900">+#endif</font>
 
 #ifdef LISP_FEATURE_SB_THREAD
 
<font color="#009900">+#ifdef LISP_FEATURE_WIN32</font>
<font color="#009900">+</font>
<font color="#009900">+enum threads_suspend_reason { SUSPEND_REASON_NONE, SUSPEND_REASON_GC, SUSPEND_REASON_INTERRUPT, SUSPEND_REASON_GCING };</font>
<font color="#009900">+</font>
<font color="#009900">+struct threads_suspend_info {</font>
<font color="#009900">+  int suspend;</font>
<font color="#009900">+  pthread_mutex_t world_lock;</font>
<font color="#009900">+  pthread_mutex_t lock;</font>
<font color="#009900">+  enum threads_suspend_reason reason;</font>
<font color="#009900">+  int phase;</font>
<font color="#009900">+  struct thread * gc_thread;</font>
<font color="#009900">+  struct thread * interrupted_thread;</font>
<font color="#009900">+};</font>
<font color="#009900">+</font>
<font color="#009900">+extern struct threads_suspend_info suspend_info;</font>
<font color="#009900">+</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 /* Only access thread state with blockables blocked. */
 static inline lispobj
 thread_state(struct thread *thread)
<font color="#0000FF">@@ -36,10 +57,33 @@ thread_state(struct thread *thread)</font>
     return state;
 }
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+static const char * get_thread_state_string(lispobj state)</font>
<font color="#009900">+{</font>
<font color="#009900">+  if (state == STATE_RUNNING) return "RUNNING";</font>
<font color="#009900">+  if (state == STATE_SUSPENDED) return "SUSPENDED";</font>
<font color="#009900">+  if (state == STATE_DEAD) return "DEAD";</font>
<font color="#009900">+  if (state == STATE_SUSPENDED_BRIEFLY) return "SUSPENDED_BRIEFLY";</font>
<font color="#009900">+  return "unknown";</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+static const char * get_thread_state_as_string(struct thread * thread)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return get_thread_state_string(thread_state(thread));</font>
<font color="#009900">+}</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 static inline void
 set_thread_state(struct thread *thread, lispobj state)
 {
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    lispobj old_state;</font>
<font color="#009900">+#endif</font>
     pthread_mutex_lock(thread-&gt;state_lock);
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    old_state = thread-&gt;state;</font>
<font color="#009900">+    odprintf("changing thread state of 0x%p from %s to %s", thread-&gt;os_thread, get_thread_state_string(old_state), get_thread_state_string(state));</font>
<font color="#009900">+#endif</font>
     thread-&gt;state = state;
     pthread_cond_broadcast(thread-&gt;state_cond);
     pthread_mutex_unlock(thread-&gt;state_lock);
<font color="#0000FF">@@ -215,6 +259,10 @@ static inline struct thread *arch_os_get_current_thread(void)</font>
 #if defined(LISP_FEATURE_SB_THREAD)
 #if defined(LISP_FEATURE_X86)
     register struct thread *me=0;
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    __asm__ __volatile__ ("movl %%fs:0xE10+(4*63), %0" : "=r"(me) :);</font>
<font color="#009900">+    return me;</font>
<font color="#009900">+#endif</font>
     if(all_threads) {
 #if defined(LISP_FEATURE_DARWIN) &amp;&amp; defined(LISP_FEATURE_RESTORE_FS_SEGMENT_REGISTER_FROM_TLS)
         sel_t sel;
diff --git a/src/runtime/win32-os.c b/src/runtime/win32-os.c
index c674ca6..6a8fe78 100644
<font color="#FF6600">--- a/src/runtime/win32-os.c</font>
<font color="#009900">+++ b/src/runtime/win32-os.c</font>
<font color="#0000FF">@@ -26,13 +26,14 @@</font>
  * yet.
  */
 
<font color="#009900">+#define _WIN32_WINNT 0x0500</font>
<font color="#009900">+#define RtlUnwind RtlUnwind_FromSystemHeaders</font>
 #include &lt;malloc.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;sys/param.h&gt;
 #include &lt;sys/file.h&gt;
 #include &lt;io.h&gt;
 #include "sbcl.h"
<font color="#FF6600">-#include "./signal.h"</font>
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
<font color="#0000FF">@@ -46,7 +47,6 @@</font>
 #include "dynbind.h"
 
 #include &lt;sys/types.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
 #include &lt;sys/time.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;unistd.h&gt;
<font color="#0000FF">@@ -68,6 +68,73 @@ int linux_sparc_siginfo_bug = 0;</font>
 int linux_supports_futex=0;
 #endif
 
<font color="#009900">+#include &lt;stdarg.h&gt;</font>
<font color="#009900">+</font>
<font color="#009900">+#undef  RtlUnwind</font>
<font color="#009900">+/* missing definitions for modern mingws */</font>
<font color="#009900">+#ifndef EH_UNWINDING</font>
<font color="#009900">+#define EH_UNWINDING 0x02</font>
<font color="#009900">+#endif</font>
<font color="#009900">+#ifndef EH_EXIT_UNWIND</font>
<font color="#009900">+#define EH_EXIT_UNWIND 0x04</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
<font color="#009900">+void odprint(const char * msg)</font>
<font color="#009900">+{</font>
<font color="#009900">+  char buf[1024];</font>
<font color="#009900">+  DWORD lastError = GetLastError();</font>
<font color="#009900">+  #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+  sprintf(buf, "[0x%p] %s\n", pthread_self(), msg);</font>
<font color="#009900">+  OutputDebugString(buf);</font>
<font color="#009900">+  #else</font>
<font color="#009900">+  OutputDebugString(msg);</font>
<font color="#009900">+  #endif</font>
<font color="#009900">+  SetLastError(lastError);</font>
<font color="#009900">+}</font>
<font color="#009900">+const char * t_nil_s(lispobj symbol);</font>
<font color="#009900">+</font>
<font color="#009900">+void odprintf_(const char * fmt, ...)</font>
<font color="#009900">+{</font>
<font color="#009900">+  char buf[1024];</font>
<font color="#009900">+  va_list args;</font>
<font color="#009900">+  int n;</font>
<font color="#009900">+  DWORD lastError = GetLastError();</font>
<font color="#009900">+  struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+  #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+  if (self) {</font>
<font color="#009900">+    sprintf(buf, "[0x%p] %s, %s, %s, %s ", pthread_self(), t_nil_s(GC_SAFE), t_nil_s(GC_INHIBIT), t_nil_s(INTERRUPTS_ENABLED), t_nil_s(IN_SAFEPOINT));</font>
<font color="#009900">+  } else {</font>
<font color="#009900">+    sprintf(buf, "[0x%p] (arch_os_get_current_thread() is NULL) ", pthread_self());</font>
<font color="#009900">+  }</font>
<font color="#009900">+  #else</font>
<font color="#009900">+  buf[0] = 0;</font>
<font color="#009900">+  #endif</font>
<font color="#009900">+  n = strlen(buf);</font>
<font color="#009900">+  va_start(args, fmt);</font>
<font color="#009900">+  vsprintf(buf + n, fmt, args);</font>
<font color="#009900">+  va_end(args);</font>
<font color="#009900">+  n = strlen(buf);</font>
<font color="#009900">+  buf[n] = '\n';</font>
<font color="#009900">+  buf[n + 1] = 0;</font>
<font color="#009900">+  OutputDebugString(buf);</font>
<font color="#009900">+  SetLastError(lastError);</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+unsigned long block_deferrables_and_return_mask()</font>
<font color="#009900">+{</font>
<font color="#009900">+  sigset_t sset;</font>
<font color="#009900">+  block_deferrable_signals(0, &amp;sset);</font>
<font color="#009900">+  return (unsigned long)sset;</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+void apply_sigmask(unsigned long sigmask)</font>
<font color="#009900">+{</font>
<font color="#009900">+  sigset_t sset = (sigset_t)sigmask;</font>
<font color="#009900">+  pthread_sigmask(SIG_SETMASK, &amp;sset, 0);</font>
<font color="#009900">+}</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 /* The exception handling function looks like this: */
 EXCEPTION_DISPOSITION handle_exception(EXCEPTION_RECORD *,
                                        struct lisp_exception_frame *,
<font color="#0000FF">@@ -107,6 +174,106 @@ inline static void *get_stack_frame(void)</font>
 }
 #endif
 
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+void alloc_gc_page()</font>
<font color="#009900">+{</font>
<font color="#009900">+  void* addr = VirtualAlloc(GC_SAFEPOINT_PAGE_ADDR, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</font>
<font color="#009900">+  if (!addr) {</font>
<font color="#009900">+    DWORD lastError = GetLastError();</font>
<font color="#009900">+    lose("in alloc_gc_page, VirtualAlloc returned NULL");</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void map_gc_page()</font>
<font color="#009900">+{</font>
<font color="#009900">+  DWORD oldProt;</font>
<font color="#009900">+  if (!VirtualProtect(GC_SAFEPOINT_PAGE_ADDR, 4, PAGE_READWRITE, &amp;oldProt)) {</font>
<font color="#009900">+    DWORD lastError = GetLastError();</font>
<font color="#009900">+    lose("in map_gc_page, VirtualProtect returned FALSE");</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
<font color="#009900">+void unmap_gc_page()</font>
<font color="#009900">+{</font>
<font color="#009900">+  DWORD oldProt;</font>
<font color="#009900">+  if (!VirtualProtect(GC_SAFEPOINT_PAGE_ADDR, 4, PAGE_NOACCESS, &amp;oldProt)) {</font>
<font color="#009900">+    DWORD lastError = GetLastError();</font>
<font color="#009900">+    lose("in unmap_gc_page, VirtualProtect returned FALSE");</font>
<font color="#009900">+  }</font>
<font color="#009900">+}</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+/* We want to get a slot in TIB that (1) is available at constant</font>
<font color="#009900">+   offset, (2) is our private property, so libraries wouldn't legally</font>
<font color="#009900">+   override it, (3) contains something predefined for threads created</font>
<font color="#009900">+   out of our sight.</font>
<font color="#009900">+</font>
<font color="#009900">+   Low 64 TLS slots are adressable directly, starting with</font>
<font color="#009900">+   FS:[#xE10]. When SBCL runtime is initialized, some of the low slots</font>
<font color="#009900">+   may be already in use by its prerequisite DLLs, as DllMain()s and</font>
<font color="#009900">+   TLS callbacks have been called already. But slot 63 is unlikely to</font>
<font color="#009900">+   be reached at this point: one slot per DLL that needs it is the</font>
<font color="#009900">+   common practice, and many system DLLs use predefined TIB-based</font>
<font color="#009900">+   areas outside conventional TLS storage and don't need TLS slots.</font>
<font color="#009900">+   With our current dependencies, even slot 2 is observed to be free</font>
<font color="#009900">+   (as of WinXP and wine).</font>
<font color="#009900">+</font>
<font color="#009900">+   Now we'll call TlsAlloc() repeatedly until slot 63 is officially</font>
<font color="#009900">+   assigned to us, then TlsFree() all other slots for normal use. TLS</font>
<font color="#009900">+   slot 63, alias FS:[#.(+ #xE10 (* 4 63))], now belongs to us.</font>
<font color="#009900">+</font>
<font color="#009900">+   To summarize, let's list the assumptions we make:</font>
<font color="#009900">+</font>
<font color="#009900">+   - TIB, which is FS segment base, contains first 64 TLS slots at the</font>
<font color="#009900">+     offset #xE10 (i.e. TIB layout compatibility);</font>
<font color="#009900">+   - TLS slots are allocated from lower to higher ones;</font>
<font color="#009900">+   - All libraries together with CRT startup have not requested 64</font>
<font color="#009900">+     slots yet.</font>
<font color="#009900">+</font>
<font color="#009900">+   All these assumptions together don't seem to be less warranted than</font>
<font color="#009900">+   the availability of TIB arbitrary data slot for our use. There are</font>
<font color="#009900">+   some more reasons to prefer slot 63 over TIB arbitrary data: (1) if</font>
<font color="#009900">+   our assumptions for slot 63 are violated, it will be detected at</font>
<font color="#009900">+   startup instead of causing some system-specific unreproducible</font>
<font color="#009900">+   problems afterwards, depending on OS and loaded foreign libraries;</font>
<font color="#009900">+   (2) if getting slot 63 reliably with our current approach will</font>
<font color="#009900">+   become impossible for some future Windows version, we can add TLS</font>
<font color="#009900">+   callback directory to SBCL binary; main image TLS callback is</font>
<font color="#009900">+   started before _any_ TLS slot is allocated by libraries, and</font>
<font color="#009900">+   some C compiler vendors rely on this fact. */</font>
<font color="#009900">+</font>
<font color="#009900">+void os_preinit()</font>
<font color="#009900">+{</font>
<font color="#009900">+    DWORD slots[TLS_MINIMUM_AVAILABLE];</font>
<font color="#009900">+    DWORD key;</font>
<font color="#009900">+    int n_slots = 0, i;</font>
<font color="#009900">+    for (i=0; i&lt;TLS_MINIMUM_AVAILABLE; ++i) {</font>
<font color="#009900">+        key = TlsAlloc();</font>
<font color="#009900">+        if (key == OUR_TLS_INDEX) {</font>
<font color="#009900">+            if (TlsGetValue(key)!=NULL)</font>
<font color="#009900">+                lose("TLS slot assertion failed: fresh slot value is not NULL");</font>
<font color="#009900">+            TlsSetValue(OUR_TLS_INDEX, (intptr_t)0xFEEDBAC4);</font>
<font color="#009900">+            if ((intptr_t)(void*)arch_os_get_current_thread()!=(intptr_t)0xFEEDBAC4)</font>
<font color="#009900">+                lose("TLS slot assertion failed: TIB layout change detected");</font>
<font color="#009900">+            TlsSetValue(OUR_TLS_INDEX, (intptr_t)0xDEADBEAD);</font>
<font color="#009900">+            if ((intptr_t)(void*)arch_os_get_current_thread()!=(intptr_t)0xDEADBEAD)</font>
<font color="#009900">+                lose("TLS slot assertion failed: TIB content unstable");</font>
<font color="#009900">+            TlsSetValue(OUR_TLS_INDEX, NULL);</font>
<font color="#009900">+            break;</font>
<font color="#009900">+        }</font>
<font color="#009900">+        slots[n_slots++]=key;</font>
<font color="#009900">+    }</font>
<font color="#009900">+    for (i=0; i&lt;n_slots; ++i) {</font>
<font color="#009900">+        TlsFree(slots[i]);</font>
<font color="#009900">+    }</font>
<font color="#009900">+    if (key!=OUR_TLS_INDEX) {</font>
<font color="#009900">+        lose("TLS slot assertion failed: slot 63 is unavailable "</font>
<font color="#009900">+             "(last TlsAlloc() returned %u)",key);</font>
<font color="#009900">+    }</font>
<font color="#009900">+}</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 void os_init(char *argv[], char *envp[])
 {
     SYSTEM_INFO system_info;
<font color="#0000FF">@@ -115,6 +282,9 @@ void os_init(char *argv[], char *envp[])</font>
     os_vm_page_size = system_info.dwPageSize;
 
     base_seh_frame = get_seh_frame();
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    alloc_gc_page();</font>
<font color="#009900">+#endif</font>
 }
 
 
<font color="#0000FF">@@ -199,6 +369,14 @@ os_invalidate(os_vm_address_t addr, os_vm_size_t len)</font>
     }
 }
 
<font color="#009900">+void</font>
<font color="#009900">+os_invalidate_free(os_vm_address_t addr, os_vm_size_t len)</font>
<font color="#009900">+{</font>
<font color="#009900">+    if (!VirtualFree(addr, 0, MEM_RELEASE)) {</font>
<font color="#009900">+        fprintf(stderr, "VirtualFree: 0x%lx.\n", GetLastError());</font>
<font color="#009900">+    }</font>
<font color="#009900">+}</font>
<font color="#009900">+</font>
 /*
  * os_map() is called to map a chunk of the core file into memory.
  *
<font color="#0000FF">@@ -301,7 +479,7 @@ extern boolean internal_errors_enabled;</font>
 #ifdef LISP_FEATURE_UD2_BREAKPOINTS
 #define IS_TRAP_EXCEPTION(exception_record, context) \
     (((exception_record)-&gt;ExceptionCode == EXCEPTION_ILLEGAL_INSTRUCTION) &amp;&amp; \
<font color="#FF6600">-     (((unsigned short *)((context)-&gt;Eip))[0] == 0x0b0f))</font>
<font color="#009900">+     (((unsigned short *)((context.win32_context)-&gt;Eip))[0] == 0x0b0f))</font>
 #define TRAP_CODE_WIDTH 2
 #else
 #define IS_TRAP_EXCEPTION(exception_record, context) \
<font color="#0000FF">@@ -320,43 +498,78 @@ handle_exception(EXCEPTION_RECORD *exception_record,</font>
                  CONTEXT *context,
                  void *dispatcher_context)
 {
<font color="#009900">+    DWORD lasterror = GetLastError();</font>
<font color="#009900">+    os_context_t ctx;</font>
<font color="#009900">+    ctx.win32_context = context;</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    struct thread * self = arch_os_get_current_thread();</font>
<font color="#009900">+    pthread_sigmask(SIG_SETMASK, NULL, &amp;ctx.sigmask);</font>
<font color="#009900">+    pthread_sigmask(SIG_BLOCK, &amp;blockable_sigset, NULL);</font>
<font color="#009900">+#endif</font>
<font color="#009900">+    /* For EXCEPTION_ACCESS_VIOLATION only. */</font>
<font color="#009900">+    void *fault_address = (void *)exception_record-&gt;ExceptionInformation[1];</font>
<font color="#009900">+    odprintf("handle exception, EIP = 0x%p, code = 0x%p (addr = 0x%p)", context-&gt;Eip, exception_record-&gt;ExceptionCode, fault_address);</font>
     if (exception_record-&gt;ExceptionFlags &amp; (EH_UNWINDING | EH_EXIT_UNWIND)) {
         /* If we're being unwound, be graceful about it. */
 
<font color="#FF6600">-        /* Undo any dynamic bindings. */</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+#endif</font>
<font color="#009900">+        /* Undo any dynamic bindings, including *gc-safe*. */</font>
         unbind_to_here(exception_frame-&gt;bindstack_pointer,
                        arch_os_get_current_thread());
<font color="#FF6600">-</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+        gc_safepoint();</font>
<font color="#009900">+        SetLastError(lasterror);</font>
<font color="#009900">+#endif</font>
         return ExceptionContinueSearch;
     }
 
<font color="#FF6600">-    /* For EXCEPTION_ACCESS_VIOLATION only. */</font>
<font color="#FF6600">-    void *fault_address = (void *)exception_record-&gt;ExceptionInformation[1];</font>
 
     if (single_stepping &amp;&amp;
         exception_record-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP) {
         /* We are doing a displaced instruction. At least function
          * end breakpoints uses this. */
<font color="#FF6600">-        restore_breakpoint_from_single_step(context);</font>
<font color="#009900">+        restore_breakpoint_from_single_step(&amp;ctx);</font>
<font color="#009900">+        #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+        gc_safepoint();</font>
<font color="#009900">+        #endif</font>
<font color="#009900">+        SetLastError(lasterror);</font>
         return ExceptionContinueExecution;
     }
 
<font color="#FF6600">-    if (IS_TRAP_EXCEPTION(exception_record, context)) {</font>
<font color="#009900">+    if (IS_TRAP_EXCEPTION(exception_record, ctx)) {</font>
         unsigned char trap;
<font color="#009900">+</font>
         /* This is just for info in case the monitor wants to print an
          * approximation. */
<font color="#FF6600">-        current_control_stack_pointer =</font>
<font color="#FF6600">-            (lispobj *)*os_context_sp_addr(context);</font>
<font color="#009900">+        access_control_stack_pointer(self) =</font>
<font color="#009900">+            (lispobj *)*os_context_sp_addr(&amp;ctx);</font>
         /* Unlike some other operating systems, Win32 leaves EIP
          * pointing to the breakpoint instruction. */
<font color="#FF6600">-        context-&gt;Eip += TRAP_CODE_WIDTH;</font>
<font color="#009900">+        ctx.win32_context-&gt;Eip += TRAP_CODE_WIDTH;</font>
         /* Now EIP points just after the INT3 byte and aims at the
          * 'kind' value (eg trap_Cerror). */
<font color="#FF6600">-        trap = *(unsigned char *)(*os_context_pc_addr(context));</font>
<font color="#FF6600">-        handle_trap(context, trap);</font>
<font color="#009900">+        trap = *(unsigned char *)(*os_context_pc_addr(&amp;ctx));</font>
<font color="#009900">+        handle_trap(&amp;ctx, trap);</font>
<font color="#009900">+        #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+        gc_safepoint();</font>
<font color="#009900">+        #endif</font>
<font color="#009900">+        SetLastError(lasterror);</font>
         /* Done, we're good to go! */
         return ExceptionContinueExecution;
     }
<font color="#009900">+    #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    else if (exception_record-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp; fault_address == GC_SAFEPOINT_PAGE_ADDR) {</font>
<font color="#009900">+      pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+      gc_safepoint();</font>
<font color="#009900">+      SetLastError(lasterror);</font>
<font color="#009900">+      return ExceptionContinueExecution;</font>
<font color="#009900">+    }</font>
<font color="#009900">+    #endif</font>
     else if (exception_record-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
              (is_valid_lisp_addr(fault_address) ||
               is_linkage_table_addr(fault_address))) {
<font color="#0000FF">@@ -389,12 +602,24 @@ handle_exception(EXCEPTION_RECORD *exception_record,</font>
                         gencgc_handle_wp_violation(fault_address);
                     }
                 }
<font color="#009900">+                #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+                pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+                gc_safepoint();</font>
<font color="#009900">+                #endif</font>
<font color="#009900">+                SetLastError(lasterror);</font>
                 return ExceptionContinueExecution;
             }
 
<font color="#FF6600">-        } else if (gencgc_handle_wp_violation(fault_address)) {</font>
<font color="#FF6600">-            /* gc accepts the wp violation, so resume where we left off. */</font>
<font color="#FF6600">-            return ExceptionContinueExecution;</font>
<font color="#009900">+        } else {</font>
<font color="#009900">+            if (gencgc_handle_wp_violation(fault_address)) {</font>
<font color="#009900">+              #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+              pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+              gc_safepoint();</font>
<font color="#009900">+              #endif</font>
<font color="#009900">+              SetLastError(lasterror);</font>
<font color="#009900">+              /* gc accepts the wp violation, so resume where we left off. */</font>
<font color="#009900">+              return ExceptionContinueExecution;</font>
<font color="#009900">+          }</font>
         }
 
         /* All else failed, drop through to the lisp-side exception handler. */
<font color="#0000FF">@@ -416,11 +641,15 @@ handle_exception(EXCEPTION_RECORD *exception_record,</font>
          * aren't supposed to happen during cold init or reinit
          * anyway. */
 
<font color="#FF6600">-        fake_foreign_function_call(context);</font>
<font color="#FF6600">-</font>
<font color="#009900">+        fake_foreign_function_call(&amp;ctx);</font>
<font color="#009900">+	</font>
<font color="#009900">+        #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+        #endif</font>
<font color="#009900">+        </font>
         /* Allocate the SAP objects while the "interrupts" are still
          * disabled. */
<font color="#FF6600">-        context_sap = alloc_sap(context);</font>
<font color="#009900">+        context_sap = alloc_sap(&amp;ctx);</font>
         exception_record_sap = alloc_sap(exception_record);
 
         /* The exception system doesn't automatically clear pending
<font color="#0000FF">@@ -433,7 +662,11 @@ handle_exception(EXCEPTION_RECORD *exception_record,</font>
                  exception_record_sap);
 
         /* If Lisp doesn't nlx, we need to put things back. */
<font color="#FF6600">-        undo_fake_foreign_function_call(context);</font>
<font color="#009900">+        undo_fake_foreign_function_call(&amp;ctx);</font>
<font color="#009900">+        #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+        gc_safepoint();</font>
<font color="#009900">+        #endif</font>
<font color="#009900">+        SetLastError(lasterror);</font>
 
         /* FIXME: HANDLE-WIN32-EXCEPTION should be allowed to decline */
         return ExceptionContinueExecution;
<font color="#0000FF">@@ -455,10 +688,15 @@ handle_exception(EXCEPTION_RECORD *exception_record,</font>
 
     fflush(stderr);
 
<font color="#FF6600">-    fake_foreign_function_call(context);</font>
<font color="#009900">+    fake_foreign_function_call(&amp;ctx);</font>
     lose("Exception too early in cold init, cannot continue.");
 
     /* FIXME: WTF? How are we supposed to end up here? */
<font color="#009900">+    #if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+    pthread_sigmask(SIG_SETMASK, &amp;ctx.sigmask, NULL);</font>
<font color="#009900">+    gc_safepoint();</font>
<font color="#009900">+    SetLastError(lasterror);</font>
<font color="#009900">+    #endif</font>
     return ExceptionContinueSearch;
 }
 
diff --git a/src/runtime/win32-os.h b/src/runtime/win32-os.h
index a09c37f..f810a79 100644
<font color="#FF6600">--- a/src/runtime/win32-os.h</font>
<font color="#009900">+++ b/src/runtime/win32-os.h</font>
<font color="#0000FF">@@ -9,6 +9,9 @@</font>
  * files for more information.
  */
 
<font color="#009900">+#define _WIN32_WINNT 0x0500</font>
<font color="#009900">+#define WIN32_LEAN_AND_MEAN</font>
<font color="#009900">+#include &lt;windows.h&gt;</font>
 #include &lt;stdlib.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;string.h&gt;
<font color="#0000FF">@@ -16,8 +19,6 @@</font>
 #include &lt;sys/stat.h&gt;
 #include &lt;unistd.h&gt;
 
<font color="#FF6600">-#define WIN32_LEAN_AND_MEAN</font>
<font color="#FF6600">-#include &lt;windows.h&gt;</font>
 #include "target-arch-os.h"
 #include "target-arch.h"
 
<font color="#0000FF">@@ -33,6 +34,7 @@ typedef void *siginfo_t;</font>
 #define OS_VM_PROT_WRITE   2
 #define OS_VM_PROT_EXECUTE 4
 
<font color="#009900">+#define OUR_TLS_INDEX 63</font>
 #define SIG_MEMORY_FAULT SIGSEGV
 
 #define SIG_STOP_FOR_GC (SIGRTMIN+1)
<font color="#0000FF">@@ -48,3 +50,4 @@ struct lisp_exception_frame {</font>
 void wos_install_interrupt_handlers(struct lisp_exception_frame *handler);
 char *dirname(char *path);
 
<font color="#009900">+void os_invalidate_free(os_vm_address_t addr, os_vm_size_t len);</font>
diff --git a/src/runtime/x86-arch.c b/src/runtime/x86-arch.c
index cbb6fb4..250ab96 100644
<font color="#FF6600">--- a/src/runtime/x86-arch.c</font>
<font color="#009900">+++ b/src/runtime/x86-arch.c</font>
<font color="#0000FF">@@ -18,7 +18,6 @@</font>
 #include "os.h"
 #include "arch.h"
 #include "lispregs.h"
<font color="#FF6600">-#include "signal.h"</font>
 #include "alloc.h"
 #include "interrupt.h"
 #include "interr.h"
<font color="#0000FF">@@ -78,7 +77,7 @@ context_eflags_addr(os_context_t *context)</font>
 #elif defined __NetBSD__
     return &amp;(context-&gt;uc_mcontext.__gregs[_REG_EFL]);
 #elif defined LISP_FEATURE_WIN32
<font color="#FF6600">-    return (int *)&amp;context-&gt;EFlags;</font>
<font color="#009900">+    return (int *)&amp;context-&gt;win32_context-&gt;EFlags;</font>
 #else
 #error unsupported OS
 #endif
diff --git a/src/runtime/x86-assem.S b/src/runtime/x86-assem.S
index 5a89a4a..349b327 100644
<font color="#FF6600">--- a/src/runtime/x86-assem.S</font>
<font color="#009900">+++ b/src/runtime/x86-assem.S</font>
<font color="#0000FF">@@ -122,6 +122,11 @@ GNAME(call_into_c):</font>
 	fstp	%st(0)
 	fstp	%st(0)
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+	pusha</font>
<font color="#009900">+	call GNAME(gc_enter_safe_region)</font>
<font color="#009900">+	popa</font>
<font color="#009900">+#endif</font>
 	call	*%eax		  # normal callout using Lisp stack
 	movl	%eax,%ecx	  # remember integer return value
 
<font color="#0000FF">@@ -145,6 +150,11 @@ GNAME(call_into_c):</font>
 
 /* Restore the return value. */
 	movl	%ecx,%eax	# maybe return value
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+	pusha</font>
<font color="#009900">+	call GNAME(gc_leave_region)</font>
<font color="#009900">+	popa</font>
<font color="#009900">+#endif</font>
 
 /* Return. */
 	jmp	*%ebx
<font color="#0000FF">@@ -163,6 +173,11 @@ Lfp_rtn_value:</font>
 
 /* We don't need to restore eax, because the result is in st(0). */
 
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+	pusha</font>
<font color="#009900">+	call GNAME(gc_leave_region)</font>
<font color="#009900">+	popa</font>
<font color="#009900">+#endif</font>
 /* Return. FIXME: It would be nice to restructure this to use RET. */	
 	jmp	*%ebx
 
<font color="#0000FF">@@ -200,6 +215,13 @@ GNAME(call_into_lisp_first_time):</font>
 	
 	.align	align_16byte,0x90
 GNAME(call_into_lisp):
<font color="#009900">+</font>
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+	pusha</font>
<font color="#009900">+	call GNAME(gc_enter_unsafe_region)</font>
<font color="#009900">+	popa</font>
<font color="#009900">+#endif</font>
<font color="#009900">+  </font>
 	pushl	%ebp		# Save old frame pointer.
 	movl	%esp,%ebp	# Establish new frame.
 Lstack:
<font color="#0000FF">@@ -261,8 +283,13 @@ Ldone:</font>
 #ifdef LISP_FEATURE_WIN32
 	/* Establish an SEH frame. */
 #ifdef LISP_FEATURE_SB_THREAD
<font color="#FF6600">-	/* FIXME: need to save BSP here. */</font>
<font color="#FF6600">-#error "need to save BSP here, but don't know how yet."</font>
<font color="#009900">+	/* Save binding stack pointer */</font>
<font color="#009900">+	subl $4, %esp</font>
<font color="#009900">+	pushl %eax</font>
<font color="#009900">+	movl %fs:0xE10+(4*63), %eax</font>
<font color="#009900">+	movl THREAD_BINDING_STACK_POINTER_OFFSET(%eax), %eax</font>
<font color="#009900">+	movl %eax, 4(%esp)</font>
<font color="#009900">+	popl %eax</font>
 #else
 	pushl	BINDING_STACK_POINTER + SYMBOL_VALUE_OFFSET
 #endif
<font color="#0000FF">@@ -306,6 +333,11 @@ LsingleValue:</font>
 	
 	popl	%ebp		# c-sp
 	movl	%edx,%eax	# c-val
<font color="#009900">+#if defined(LISP_FEATURE_WIN32) &amp;&amp; defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+	pusha</font>
<font color="#009900">+	call GNAME(gc_leave_region)</font>
<font color="#009900">+	popa</font>
<font color="#009900">+#endif</font>
 	ret
 	SIZE(GNAME(call_into_lisp))
 
<font color="#0000FF">@@ -539,6 +571,7 @@ DEFINE_ALLOC_TO_REG(alloc_16_to_edi,%edi,$16)</font>
 #define START_REGION GNAME(boxed_region)
 #endif
 
<font color="#009900">+/* FIXME Win32 */</font>
 #define ALLOC_OVERFLOW(size)                                    \
         /* Calculate the size for the allocation. */            \
         subl    START_REGION,size;                              \
diff --git a/src/runtime/x86-win32-os.c b/src/runtime/x86-win32-os.c
index fc076de..62b5193 100644
<font color="#FF6600">--- a/src/runtime/x86-win32-os.c</font>
<font color="#009900">+++ b/src/runtime/x86-win32-os.c</font>
<font color="#0000FF">@@ -22,7 +22,6 @@</font>
 #include &lt;unistd.h&gt;
 #include &lt;errno.h&gt;
 
<font color="#FF6600">-#include "./signal.h"</font>
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
<font color="#0000FF">@@ -32,7 +31,7 @@</font>
 #include "sbcl.h"
 
 #include &lt;sys/types.h&gt;
<font color="#FF6600">-#include &lt;signal.h&gt;</font>
<font color="#009900">+#include "runtime.h"</font>
 #include &lt;sys/time.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;unistd.h&gt;
<font color="#0000FF">@@ -86,40 +85,7 @@ int arch_os_thread_init(struct thread *thread)</font>
     }
 
 #ifdef LISP_FEATURE_SB_THREAD
<font color="#FF6600">-    /* this must be called from a function that has an exclusive lock</font>
<font color="#FF6600">-     * on all_threads</font>
<font color="#FF6600">-     */</font>
<font color="#FF6600">-    struct user_desc ldt_entry = {</font>
<font color="#FF6600">-        1, 0, 0, /* index, address, length filled in later */</font>
<font color="#FF6600">-        1, MODIFY_LDT_CONTENTS_DATA, 0, 0, 0, 1</font>
<font color="#FF6600">-    };</font>
<font color="#FF6600">-    int n;</font>
<font color="#FF6600">-    get_spinlock(&amp;modify_ldt_lock,thread);</font>
<font color="#FF6600">-    n=modify_ldt(0,local_ldt_copy,sizeof local_ldt_copy);</font>
<font color="#FF6600">-    /* get next free ldt entry */</font>
<font color="#FF6600">-</font>
<font color="#FF6600">-    if(n) {</font>
<font color="#FF6600">-        u32 *p;</font>
<font color="#FF6600">-        for(n=0,p=local_ldt_copy;*p;p+=LDT_ENTRY_SIZE/sizeof(u32))</font>
<font color="#FF6600">-            n++;</font>
<font color="#FF6600">-    }</font>
<font color="#FF6600">-    ldt_entry.entry_number=n;</font>
<font color="#FF6600">-    ldt_entry.base_addr=(unsigned long) thread;</font>
<font color="#FF6600">-    ldt_entry.limit=dynamic_values_bytes;</font>
<font color="#FF6600">-    ldt_entry.limit_in_pages=0;</font>
<font color="#FF6600">-    if (modify_ldt (1, &amp;ldt_entry, sizeof (ldt_entry)) != 0) {</font>
<font color="#FF6600">-        modify_ldt_lock=0;</font>
<font color="#FF6600">-        /* modify_ldt call failed: something magical is not happening */</font>
<font color="#FF6600">-        return -1;</font>
<font color="#FF6600">-    }</font>
<font color="#FF6600">-    __asm__ __volatile__ ("movw %w0, %%fs" : : "q"</font>
<font color="#FF6600">-                          ((n &lt;&lt; 3) /* selector number */</font>
<font color="#FF6600">-                           + (1 &lt;&lt; 2) /* TI set = LDT */</font>
<font color="#FF6600">-                           + 3)); /* privilege level */</font>
<font color="#FF6600">-    thread-&gt;tls_cookie=n;</font>
<font color="#FF6600">-    modify_ldt_lock=0;</font>
<font color="#FF6600">-</font>
<font color="#FF6600">-    if(n&lt;0) return 0;</font>
<font color="#009900">+    TlsSetValue(OUR_TLS_INDEX,thread);</font>
 #endif
 
     return 1;
<font color="#0000FF">@@ -133,18 +99,25 @@ int arch_os_thread_cleanup(struct thread *thread) {</font>
     return 0;
 }
 
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+sigset_t *os_context_sigmask_addr(os_context_t *context)</font>
<font color="#009900">+{</font>
<font color="#009900">+  return &amp;context-&gt;sigmask;</font>
<font color="#009900">+}</font>
<font color="#009900">+#endif</font>
<font color="#009900">+</font>
 os_context_register_t *
 os_context_register_addr(os_context_t *context, int offset)
 {
     switch(offset) {
<font color="#FF6600">-    case reg_EAX: return &amp;context-&gt;Eax;</font>
<font color="#FF6600">-    case reg_ECX: return &amp;context-&gt;Ecx;</font>
<font color="#FF6600">-    case reg_EDX: return &amp;context-&gt;Edx;</font>
<font color="#FF6600">-    case reg_EBX: return &amp;context-&gt;Ebx;</font>
<font color="#FF6600">-    case reg_ESP: return &amp;context-&gt;Esp;</font>
<font color="#FF6600">-    case reg_EBP: return &amp;context-&gt;Ebp;</font>
<font color="#FF6600">-    case reg_ESI: return &amp;context-&gt;Esi;</font>
<font color="#FF6600">-    case reg_EDI: return &amp;context-&gt;Edi;</font>
<font color="#009900">+    case reg_EAX: return &amp;context-&gt;win32_context-&gt;Eax;</font>
<font color="#009900">+    case reg_ECX: return &amp;context-&gt;win32_context-&gt;Ecx;</font>
<font color="#009900">+    case reg_EDX: return &amp;context-&gt;win32_context-&gt;Edx;</font>
<font color="#009900">+    case reg_EBX: return &amp;context-&gt;win32_context-&gt;Ebx;</font>
<font color="#009900">+    case reg_ESP: return &amp;context-&gt;win32_context-&gt;Esp;</font>
<font color="#009900">+    case reg_EBP: return &amp;context-&gt;win32_context-&gt;Ebp;</font>
<font color="#009900">+    case reg_ESI: return &amp;context-&gt;win32_context-&gt;Esi;</font>
<font color="#009900">+    case reg_EDI: return &amp;context-&gt;win32_context-&gt;Edi;</font>
     default: return 0;
     }
 }
<font color="#0000FF">@@ -152,32 +125,32 @@ os_context_register_addr(os_context_t *context, int offset)</font>
 os_context_register_t *
 os_context_pc_addr(os_context_t *context)
 {
<font color="#FF6600">-    return &amp;context-&gt;Eip; /*  REG_EIP */</font>
<font color="#009900">+    return &amp;context-&gt;win32_context-&gt;Eip; /*  REG_EIP */</font>
 }
 
 os_context_register_t *
 os_context_sp_addr(os_context_t *context)
 {
<font color="#FF6600">-    return &amp;context-&gt;Esp; /* REG_UESP */</font>
<font color="#009900">+    return &amp;context-&gt;win32_context-&gt;Esp; /* REG_UESP */</font>
 }
 
 os_context_register_t *
 os_context_fp_addr(os_context_t *context)
 {
<font color="#FF6600">-    return &amp;context-&gt;Ebp; /* REG_EBP */</font>
<font color="#009900">+    return &amp;context-&gt;win32_context-&gt;Ebp; /* REG_EBP */</font>
 }
 
 unsigned long
 os_context_fp_control(os_context_t *context)
 {
<font color="#FF6600">-    return ((((context-&gt;FloatSave.ControlWord) &amp; 0xffff) ^ 0x3f) |</font>
<font color="#FF6600">-            (((context-&gt;FloatSave.StatusWord) &amp; 0xffff) &lt;&lt; 16));</font>
<font color="#009900">+    return ((((context-&gt;win32_context-&gt;FloatSave.ControlWord) &amp; 0xffff) ^ 0x3f) |</font>
<font color="#009900">+            (((context-&gt;win32_context-&gt;FloatSave.StatusWord) &amp; 0xffff) &lt;&lt; 16));</font>
 }
 
 void
 os_restore_fp_control(os_context_t *context)
 {
<font color="#FF6600">-    asm ("fldcw %0" : : "m" (context-&gt;FloatSave.ControlWord));</font>
<font color="#009900">+    asm ("fldcw %0" : : "m" (context-&gt;win32_context-&gt;FloatSave.ControlWord));</font>
 }
 
 void
diff --git a/src/runtime/x86-win32-os.h b/src/runtime/x86-win32-os.h
index e703338..b17c020 100644
<font color="#FF6600">--- a/src/runtime/x86-win32-os.h</font>
<font color="#009900">+++ b/src/runtime/x86-win32-os.h</font>
<font color="#0000FF">@@ -1,7 +1,13 @@</font>
 #ifndef _X86_WIN32_OS_H
 #define _X86_WIN32_OS_H
 
<font color="#FF6600">-typedef CONTEXT os_context_t;</font>
<font color="#009900">+typedef struct os_context_t {</font>
<font color="#009900">+  CONTEXT* win32_context;</font>
<font color="#009900">+#if defined(LISP_FEATURE_SB_THREAD)</font>
<font color="#009900">+  sigset_t sigmask;</font>
<font color="#009900">+#endif</font>
<font color="#009900">+} os_context_t;</font>
<font color="#009900">+</font>
 typedef long os_context_register_t;
 
 static inline os_context_t *arch_os_get_context(void **void_context)
diff --git a/tests/threads.impure.lisp b/tests/threads.impure.lisp
index 8914dda..226f6ae 100644
<font color="#FF6600">--- a/tests/threads.impure.lisp</font>
<font color="#009900">+++ b/tests/threads.impure.lisp</font>
<font color="#0000FF">@@ -196,6 +196,8 @@</font>
 ;;; For one of the interupt-thread tests, we want a foreign function
 ;;; that does not make syscalls
 
<font color="#009900">+#-win32</font>
<font color="#009900">+(progn</font>
 (with-open-file (o "threads-foreign.c" :direction :output :if-exists :supersede)
   (format o "void loop_forever() { while(1) ; }~%"))
 (sb-ext:run-program "/bin/sh"
<font color="#0000FF">@@ -205,7 +207,7 @@</font>
 (sb-alien:load-shared-object (truename "threads-foreign.so"))
 (sb-alien:define-alien-routine loop-forever sb-alien:void)
 (delete-file "threads-foreign.c")
<font color="#FF6600">-</font>
<font color="#009900">+)</font>
 
 ;;; elementary "can we get a lock and release it again"
 (with-test (:name (:mutex :basics))
<font color="#0000FF">@@ -394,7 +396,11 @@</font>
   `(handler-case (progn (progn ,@body) nil)
     (sb-ext:timeout () t)))
 
<font color="#FF6600">-(with-test (:name (:semaphore :wait-forever))</font>
<font color="#009900">+(with-test (:name (:semaphore :wait-forever)</font>
<font color="#009900">+            :fails-on :win32)</font>
<font color="#009900">+  #+win32</font>
<font color="#009900">+  (error "No timeout support on win32")</font>
<font color="#009900">+  #-win32</font>
   (let ((sem (make-semaphore :count 0)))
     (assert (raises-timeout-p
               (sb-ext:with-timeout 0.1
<font color="#0000FF">@@ -529,10 +535,15 @@</font>
   (let ((child (test-interrupt (lambda () (loop)))))
     (terminate-thread child)))
 
<font color="#FF6600">-(with-test (:name (:interrupt-thread :interrupt-foreign-loop))</font>
<font color="#009900">+(with-test (:name (:interrupt-thread :interrupt-foreign-loop)</font>
<font color="#009900">+            :fails-on :win32)</font>
<font color="#009900">+  #+win32 (error "Foreign loop is not interruptible on win32")</font>
<font color="#009900">+  #-win32</font>
   (test-interrupt #'loop-forever :quit))
 
<font color="#FF6600">-(with-test (:name (:interrupt-thread :interrupt-sleep))</font>
<font color="#009900">+(with-test (:name (:interrupt-thread :interrupt-sleep)</font>
<font color="#009900">+            :fails-on :win32)</font>
<font color="#009900">+  #+win32 (error "Sleep is not interruptible on win32")</font>
   (let ((child (test-interrupt (lambda () (loop (sleep 2000))))))
     (terminate-thread child)
     (wait-for-threads (list child))))
<font color="#0000FF">@@ -855,7 +866,9 @@</font>
      (wait-for-gc)
      (decf sb-vm::*binding-stack-pointer* 2))))
 
<font color="#FF6600">-(with-test (:name (:binding-stack-gc-safety))</font>
<font color="#009900">+(with-test (:name (:binding-stack-gc-safety)</font>
<font color="#009900">+            :fails-on :win32)</font>
<font color="#009900">+  #+win32 (error "Not appliable on platform with safepoints")</font>
   (let (threads)
     (unwind-protect
          (progn
diff --git a/tests/threads.pure.lisp b/tests/threads.pure.lisp
index bc2b94c..10a8711 100644
<font color="#FF6600">--- a/tests/threads.pure.lisp</font>
<font color="#009900">+++ b/tests/threads.pure.lisp</font>
<font color="#0000FF">@@ -40,7 +40,7 @@</font>
 
 ;;; Terminating a thread that's waiting for the terminal.
 
<font color="#FF6600">-#+sb-thread</font>
<font color="#009900">+#+(and sb-thread (not win32))</font>
 (let ((thread (make-thread (lambda ()
                              (sb-thread::get-foreground)))))
   (sleep 1)
<font color="#0000FF">@@ -103,8 +103,10 @@</font>
     (mapcar #'sb-thread:join-thread threads)
     (assert (not oops))))
 
<font color="#009900">+;; win32 doesn't have signal timers</font>
 #+sb-thread
<font color="#FF6600">-(with-test (:name :semaphore-multiple-waiters)</font>
<font color="#009900">+(with-test (:name :semaphore-multiple-waiters</font>
<font color="#009900">+            :fails-on :win32)</font>
   (let ((semaphore (make-semaphore :name "test sem")))
     (labels ((make-readers (n i)
                (values
</tt></pre>
  </body>
</html>
